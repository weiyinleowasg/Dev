{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory name",
			"defaultValue": "DWH-NonProd-ADF"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/ProcessTigermoth_DeleteForecastDataVersion_pl')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "GetForecastDataVersion",
						"type": "Lookup",
						"dependsOn": [
							{
								"activity": "SetEtlUtcTag",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzureSqlSource",
								"sqlReaderQuery": "SELECT DISTINCT VERSION_NAME, FUND_ID, ASSET_ID\nFROM [relational].[Forecast_Asset_reference]\nWHERE record_deleted_flag = 0 AND IsProcessed = 0",
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "SQLrelationfctrefasset_ds",
								"type": "DatasetReference",
								"parameters": {}
							},
							"firstRowOnly": false
						}
					},
					{
						"name": "ProcessDeleteForecastData",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "GetForecastDataVersion",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('GetForecastDataVersion').output.value",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "SPdelete_Version",
									"type": "SqlServerStoredProcedure",
									"dependsOn": [],
									"policy": {
										"timeout": "7.00:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"storedProcedureName": "[[log].[Delete_Forecast_Data]",
										"storedProcedureParameters": {
											"Asset_Id": {
												"value": {
													"value": "@{item().ASSET_ID}",
													"type": "Expression"
												},
												"type": "String"
											},
											"Fund_Id": {
												"value": {
													"value": "@{item().FUND_ID}",
													"type": "Expression"
												},
												"type": "String"
											},
											"Version_Name": {
												"value": {
													"value": "@{item().VERSION_NAME}",
													"type": "Expression"
												},
												"type": "String"
											}
										}
									},
									"linkedServiceName": {
										"referenceName": "SQLdbConnection",
										"type": "LinkedServiceReference"
									}
								}
							]
						}
					},
					{
						"name": "SetEtlUtcTag",
						"type": "SetVariable",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"variableName": "Etl_Utc_Tag",
							"value": {
								"value": "@utcnow()",
								"type": "Expression"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"variables": {
					"Success_Fail_Header": {
						"type": "String",
						"defaultValue": "***SUCCESS***"
					},
					"Etl_Utc_Tag": {
						"type": "String",
						"defaultValue": "2019-10-22"
					}
				},
				"annotations": [],
				"lastPublishTime": "2020-08-28T02:28:09Z"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/ProcessTigermoth_DeleteForecastDataVersion_pl_old20200312')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "GetForecastDataVersion",
						"type": "Lookup",
						"dependsOn": [
							{
								"activity": "SetEtlUtcTag",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzureSqlSource",
								"sqlReaderQuery": "SELECT VERSION_NAME, COUNT(*) AS TO_PROCESS\nFROM [relational].[Forecast_Asset_reference]\nWHERE record_deleted_flag = 0 AND IsProcessed = 0\nGROUP BY VERSION_NAME",
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "SQLrelationfctrefasset_ds",
								"type": "DatasetReference",
								"parameters": {}
							},
							"firstRowOnly": false
						}
					},
					{
						"name": "ProcessDeleteForecastData",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "GetForecastDataVersion",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('GetForecastDataVersion').output.value",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "SPdelete_Version",
									"type": "SqlServerStoredProcedure",
									"dependsOn": [],
									"policy": {
										"timeout": "7.00:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"storedProcedureName": "[[log].[Delete_Forecast_Data]",
										"storedProcedureParameters": {
											"Version_Name": {
												"value": {
													"value": "@{item().VERSION_NAME}",
													"type": "Expression"
												},
												"type": "String"
											}
										}
									},
									"linkedServiceName": {
										"referenceName": "SQLdbConnection",
										"type": "LinkedServiceReference"
									}
								}
							]
						}
					},
					{
						"name": "SetEtlUtcTag",
						"type": "SetVariable",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"variableName": "Etl_Utc_Tag",
							"value": {
								"value": "@utcnow()",
								"type": "Expression"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"variables": {
					"Success_Fail_Header": {
						"type": "String",
						"defaultValue": "***SUCCESS***"
					},
					"Etl_Utc_Tag": {
						"type": "String",
						"defaultValue": "2019-10-22"
					}
				},
				"annotations": [],
				"lastPublishTime": "2020-08-28T02:28:08Z"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/ProcessTigermoth_ExpireForecastAssetRef_pl')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "GetForecastAssetRef",
						"type": "Lookup",
						"dependsOn": [
							{
								"activity": "SetEtlUtcTag",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzureSqlSource",
								"sqlReaderQuery": "SELECT VERSION_NAME, COUNT(*) AS TO_PROCESS\nFROM [relational].[Forecast_Asset_reference]\nWHERE record_deleted_flag = 0 AND IsProcessed = 0\nGROUP BY VERSION_NAME",
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "SQLrelationfctrefasset_ds",
								"type": "DatasetReference",
								"parameters": {}
							},
							"firstRowOnly": false
						}
					},
					{
						"name": "ProcessExpireForecastAssetRef",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "GetForecastAssetRef",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('GetForecastAssetRef').output.value",
								"type": "Expression"
							},
							"isSequential": true,
							"activities": [
								{
									"name": "SPexpire_Version",
									"type": "SqlServerStoredProcedure",
									"dependsOn": [],
									"policy": {
										"timeout": "7.00:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"storedProcedureName": "[[log].[Expire_Forecast_Asset_Ref]",
										"storedProcedureParameters": {
											"Version_Name": {
												"value": {
													"value": "@{item().VERSION_NAME}",
													"type": "Expression"
												},
												"type": "String"
											}
										}
									},
									"linkedServiceName": {
										"referenceName": "SQLdbConnection",
										"type": "LinkedServiceReference"
									}
								}
							]
						}
					},
					{
						"name": "SetEtlUtcTag",
						"type": "SetVariable",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"variableName": "Etl_Utc_Tag",
							"value": {
								"value": "@utcnow()",
								"type": "Expression"
							}
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"variables": {
					"Success_Fail_Header": {
						"type": "String",
						"defaultValue": "***SUCCESS***"
					},
					"Etl_Utc_Tag": {
						"type": "String",
						"defaultValue": "2019-10-22"
					}
				},
				"annotations": [],
				"lastPublishTime": "2020-08-28T02:28:09Z"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/ProcessTigermoth_Sendmail_OffsetError_pl')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "GetOffsetError",
						"type": "Lookup",
						"dependsOn": [
							{
								"activity": "SetEtlUtcTag",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "AzureSqlSource",
								"sqlReaderQuery": "SELECT CASE WHEN OFFSET_ERROR IS NULL THEN '' ELSE OFFSET_ERROR END AS OFFSET_ERROR FROM (\nSELECT \nstuff( (SELECT ', '+CONCAT(FAR.Fund_ID,'  ',FAR.Asset_ID,'  ',FAR.Version_name,\n'  Asset-Ref-Asset-Offset: ',FAR.Asset_Offset,'  Parameter-Asset-Offset: ',FCP.Asset_offset)\nFROM relational.Forecast_Asset_reference FAR\nJOIN staging.Forecast_Param FCP\nON FAR.Fund_ID = FCP.Fund_ID AND FAR.Asset_ID = FCP.Asset_ID \nAND FAR.Version_name = FCP.Version_name\nWHERE FAR.Asset_Offset < CAST(FCP.Asset_offset AS INT) \nAND FAR.record_deleted_flag = 0 AND FAR.IsProcessed = 0\nORDER BY FAR.Version_name\nFOR XML PATH(''), TYPE).value('.', 'varchar(max)'),1,1,'') AS OFFSET_ERROR\n)x",
								"partitionOption": "None"
							},
							"dataset": {
								"referenceName": "SQLrelationfctrefasset_ds",
								"type": "DatasetReference",
								"parameters": {}
							},
							"firstRowOnly": true
						}
					},
					{
						"name": "SetEtlUtcTag",
						"type": "SetVariable",
						"dependsOn": [],
						"userProperties": [],
						"typeProperties": {
							"variableName": "Etl_Utc_Tag",
							"value": {
								"value": "@utcnow()",
								"type": "Expression"
							}
						}
					},
					{
						"name": "IfOffsetErrorExistSendmail",
						"type": "IfCondition",
						"dependsOn": [
							{
								"activity": "GetOffsetError",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"expression": {
								"value": "@not(equals(activity('GetOffsetError').output.firstRow.OFFSET_ERROR,''))",
								"type": "Expression"
							},
							"ifTrueActivities": [
								{
									"name": "SendMailOffsetError",
									"type": "WebActivity",
									"dependsOn": [],
									"policy": {
										"timeout": "7.00:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"url": "https://prod-12.australiaeast.logic.azure.com:443/workflows/f7a9fbbc810043f28c16fd6bcf3b2f68/triggers/manual/paths/invoke?api-version=2016-10-01&sp=%2Ftriggers%2Fmanual%2Frun&sv=1.0&sig=8yphnNtSS85GDIgCI8OiOwpDghciKo7S9hRjuy5ITI4",
										"method": "POST",
										"headers": {
											"Content-Type": "application/json"
										},
										"body": {
											"dataFactoryName": "@pipeline().parameters.Parent_DataFactory",
											"pipelineName": "@pipeline().parameters.Parent_Pipeline",
											"messageHeader": "!!!Forecast Offest Error!!!",
											"messageProcessed": "@activity('GetOffsetError').output.firstRow",
											"messageNotProcessed": "",
											"messageErrorDuringProcess": ""
										}
									}
								}
							]
						}
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"parameters": {
					"Parent_DataFactory": {
						"type": "string"
					},
					"Parent_Pipeline": {
						"type": "string"
					},
					"Success_Fail_Header": {
						"type": "string"
					}
				},
				"variables": {
					"Success_Fail_Header": {
						"type": "String",
						"defaultValue": "***SUCCESS***"
					},
					"Etl_Utc_Tag": {
						"type": "String",
						"defaultValue": "2019-10-22"
					}
				},
				"annotations": [],
				"lastPublishTime": "2020-08-28T02:28:09Z"
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/pl_d365crmextract')]",
			"type": "Microsoft.DataFactory/factories/pipelines",
			"apiVersion": "2018-06-01",
			"properties": {
				"activities": [
					{
						"name": "D365CRM_GetToken",
						"type": "WebActivity",
						"dependsOn": [],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"url": {
								"value": "https://login.microsoftonline.com/9f5fb3c2-436f-448a-87ce-a0931ec94aba/oauth2/token",
								"type": "Expression"
							},
							"method": "POST",
							"headers": {
								"Content-Type": {
									"value": "application/x-www-form-urlencoded",
									"type": "Expression"
								}
							},
							"body": {
								"value": "grant_type=client_credentials&tenant_id=9f5fb3c2-436f-448a-87ce-a0931ec94aba&client_id=18ae9f8d-c9c2-4baf-8157-b82410f34429&client_secret=63c8Q~Su82pzTyTOR6mhFh1Q2d3r_FaQPhXGcaxe&resource=https://newforestsdev.crm6.dynamics.com/",
								"type": "Expression"
							}
						}
					},
					{
						"name": "ForEachAPI",
						"type": "ForEach",
						"dependsOn": [
							{
								"activity": "SelectAllAPI",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"userProperties": [],
						"typeProperties": {
							"items": {
								"value": "@activity('SelectAllAPI').output.resultSets[0].rows",
								"type": "Expression"
							},
							"isSequential": false,
							"batchCount": 3,
							"activities": [
								{
									"name": "D365APItoBlob",
									"type": "Copy",
									"dependsOn": [],
									"policy": {
										"timeout": "7.00:00:00",
										"retry": 0,
										"retryIntervalInSeconds": 30,
										"secureOutput": false,
										"secureInput": false
									},
									"userProperties": [],
									"typeProperties": {
										"source": {
											"type": "RestSource",
											"httpRequestTimeout": "00:01:40",
											"requestInterval": "00.00:00:00.010",
											"requestMethod": "GET",
											"additionalHeaders": {
												"Authorization": {
													"value": "@{concat(' Bearer ', activity('D365CRM_GetToken').output.access_token)}",
													"type": "Expression"
												}
											},
											"paginationRules": {
												"supportRFC5988": "true"
											}
										},
										"sink": {
											"type": "JsonSink",
											"storeSettings": {
												"type": "AzureBlobStorageWriteSettings"
											},
											"formatSettings": {
												"type": "JsonWriteSettings"
											}
										},
										"enableStaging": false
									},
									"inputs": [
										{
											"referenceName": "API_D365CRM",
											"type": "DatasetReference",
											"parameters": {
												"ObjectSourceName": {
													"value": "@item().Source_Object_Name",
													"type": "Expression"
												}
											}
										}
									],
									"outputs": [
										{
											"referenceName": "ds_D365Output_json",
											"type": "DatasetReference",
											"parameters": {
												"FileName": {
													"value": "@concat(item().Object_Name,formatDateTime(convertTimeZone(utcNow(),'utc','E. Australia Standard Time'),'yyyyMMdd'))",
													"type": "Expression"
												}
											}
										}
									]
								}
							]
						}
					},
					{
						"name": "SelectAllAPI",
						"type": "Script",
						"dependsOn": [
							{
								"activity": "D365CRM_GetToken",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"linkedServiceName": {
							"referenceName": "SQLdbConnection",
							"type": "LinkedServiceReference"
						},
						"typeProperties": {
							"scripts": [
								{
									"type": "Query",
									"text": {
										"value": "SELECT * FROM log.D365CRM_ExtractRegister",
										"type": "Expression"
									}
								}
							]
						}
					},
					{
						"name": "D365BlobtoTableAsset",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "ForEachAPI",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "JsonSource",
								"storeSettings": {
									"type": "AzureBlobStorageReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "JsonReadSettings"
								}
							},
							"sink": {
								"type": "AzureSqlSink",
								"writeBehavior": "insert",
								"sqlWriterUseTableLock": false,
								"tableOption": "autoCreate",
								"disableMetricsCollection": false
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"path": "[['mcs_assetuniqueid']"
										},
										"sink": {
											"name": "Asset_ID"
										}
									},
									{
										"source": {
											"path": "[['statecode']"
										},
										"sink": {
											"name": "Status",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['statuscode']"
										},
										"sink": {
											"name": "Status_Reason"
										}
									},
									{
										"source": {
											"path": "[['mcs_name']"
										},
										"sink": {
											"name": "Name",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['mcs_assetid']"
										},
										"sink": {
											"name": "Asset"
										}
									}
								],
								"collectionReference": "$['value']"
							}
						},
						"inputs": [
							{
								"referenceName": "ds_D365Output_json",
								"type": "DatasetReference",
								"parameters": {
									"FileName": {
										"value": "@concat('Asset',formatDateTime(convertTimeZone(utcNow(),'utc','E. Australia Standard Time'),'yyyyMMdd'))",
										"type": "Expression"
									}
								}
							}
						],
						"outputs": [
							{
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference",
								"parameters": {
									"Schema": {
										"value": "raw",
										"type": "Expression"
									},
									"TableName": {
										"value": "D365CRM_Asset",
										"type": "Expression"
									}
								}
							}
						]
					},
					{
						"name": "D365BlobtoTableAUMMovementType",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "ForEachAPI",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "JsonSource",
								"storeSettings": {
									"type": "AzureBlobStorageReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "JsonReadSettings"
								}
							},
							"sink": {
								"type": "AzureSqlSink",
								"writeBehavior": "insert",
								"sqlWriterUseTableLock": false,
								"tableOption": "autoCreate",
								"disableMetricsCollection": false
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"path": "[['statecode']"
										},
										"sink": {
											"name": "Status",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['statuscode']"
										},
										"sink": {
											"name": "Status_Reason"
										}
									},
									{
										"source": {
											"path": "[['mcs_aummovementtypeid']"
										},
										"sink": {
											"name": "AUM_Movement_Type"
										}
									},
									{
										"source": {
											"path": "[['mcs_name']"
										},
										"sink": {
											"name": "Name",
											"type": "String"
										}
									}
								],
								"collectionReference": "$['value']"
							}
						},
						"inputs": [
							{
								"referenceName": "ds_D365Output_json",
								"type": "DatasetReference",
								"parameters": {
									"FileName": {
										"value": "@concat('AUM Movement Type',formatDateTime(convertTimeZone(utcNow(),'utc','E. Australia Standard Time'),'yyyyMMdd'))",
										"type": "Expression"
									}
								}
							}
						],
						"outputs": [
							{
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference",
								"parameters": {
									"Schema": {
										"value": "raw",
										"type": "Expression"
									},
									"TableName": {
										"value": "D365CRM_AUMMovementType",
										"type": "Expression"
									}
								}
							}
						]
					},
					{
						"name": "D365BlobtoTableAUMMovement",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "ForEachAPI",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "JsonSource",
								"storeSettings": {
									"type": "AzureBlobStorageReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "JsonReadSettings"
								}
							},
							"sink": {
								"type": "AzureSqlSink",
								"writeBehavior": "insert",
								"sqlWriterUseTableLock": false,
								"tableOption": "autoCreate",
								"disableMetricsCollection": false
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"path": "[['mcs_note']"
										},
										"sink": {
											"name": "Note",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['mcs_transactiontype']"
										},
										"sink": {
											"name": "Transaction_Type",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['_mcs_movementtype_value']"
										},
										"sink": {
											"name": "Movement_Type",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['statuscode']"
										},
										"sink": {
											"name": "Status_Reason",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['mcs_uom']"
										},
										"sink": {
											"name": "UOM",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['_mcs_aum_value']"
										},
										"sink": {
											"name": "AUM",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['mcs_aummovementid']"
										},
										"sink": {
											"name": "AUM_Movement",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['mcs_amount']"
										},
										"sink": {
											"name": "Amount",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['statecode']"
										},
										"sink": {
											"name": "Status",
											"type": "String"
										}
									}
								],
								"collectionReference": "$['value']"
							}
						},
						"inputs": [
							{
								"referenceName": "ds_D365Output_json",
								"type": "DatasetReference",
								"parameters": {
									"FileName": {
										"value": "@concat('AUM Movement',formatDateTime(convertTimeZone(utcNow(),'utc','E. Australia Standard Time'),'yyyyMMdd'))",
										"type": "Expression"
									}
								}
							}
						],
						"outputs": [
							{
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference",
								"parameters": {
									"Schema": {
										"value": "raw",
										"type": "Expression"
									},
									"TableName": {
										"value": "D365CRM_AUMMovement",
										"type": "Expression"
									}
								}
							}
						]
					},
					{
						"name": "D365BlobtoTableAUM",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "ForEachAPI",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "JsonSource",
								"storeSettings": {
									"type": "AzureBlobStorageReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "JsonReadSettings"
								}
							},
							"sink": {
								"type": "AzureSqlSink",
								"writeBehavior": "insert",
								"sqlWriterUseTableLock": false,
								"tableOption": "autoCreate",
								"disableMetricsCollection": false
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"path": "[['mcs_aumid']"
										},
										"sink": {
											"name": "AUM",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['_mcs_asset_value']"
										},
										"sink": {
											"name": "Asset",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['mcs_periodclose']"
										},
										"sink": {
											"name": "Period_Close",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['statuscode']"
										},
										"sink": {
											"name": "Status_Reason",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['mcs_sourcedocumentreference']"
										},
										"sink": {
											"name": "Source_Document_Ref",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['mcs_subtype']"
										},
										"sink": {
											"name": "Sub_Type",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['mcs_region']"
										},
										"sink": {
											"name": "Region",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['mcs_date']"
										},
										"sink": {
											"name": "Date",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['mcs_type']"
										},
										"sink": {
											"name": "Type",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['statecode']"
										},
										"sink": {
											"name": "Status",
											"type": "String"
										}
									}
								],
								"collectionReference": "$['value']"
							}
						},
						"inputs": [
							{
								"referenceName": "ds_D365Output_json",
								"type": "DatasetReference",
								"parameters": {
									"FileName": {
										"value": "@concat('AUM',formatDateTime(convertTimeZone(utcNow(),'utc','E. Australia Standard Time'),'yyyyMMdd'))",
										"type": "Expression"
									}
								}
							}
						],
						"outputs": [
							{
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference",
								"parameters": {
									"Schema": {
										"value": "raw",
										"type": "Expression"
									},
									"TableName": {
										"value": "D365CRM_AUM",
										"type": "Expression"
									}
								}
							}
						]
					},
					{
						"name": "D365BlobtoTableConsultant",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "ForEachAPI",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "JsonSource",
								"storeSettings": {
									"type": "AzureBlobStorageReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "JsonReadSettings"
								}
							},
							"sink": {
								"type": "AzureSqlSink",
								"writeBehavior": "insert",
								"sqlWriterUseTableLock": false,
								"tableOption": "autoCreate",
								"disableMetricsCollection": false
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"path": "[['statecode']"
										},
										"sink": {
											"name": "Status",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['name']"
										},
										"sink": {
											"name": "Name",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['statuscode']"
										},
										"sink": {
											"name": "Status_Reason",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['accountid']"
										},
										"sink": {
											"name": "Account",
											"type": "String"
										}
									}
								],
								"collectionReference": "$['value']"
							}
						},
						"inputs": [
							{
								"referenceName": "ds_D365Output_json",
								"type": "DatasetReference",
								"parameters": {
									"FileName": {
										"value": "@concat('Consultant',formatDateTime(convertTimeZone(utcNow(),'utc','E. Australia Standard Time'),'yyyyMMdd'))",
										"type": "Expression"
									}
								}
							}
						],
						"outputs": [
							{
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference",
								"parameters": {
									"Schema": {
										"value": "raw",
										"type": "Expression"
									},
									"TableName": {
										"value": "D365CRM_Consultant",
										"type": "Expression"
									}
								}
							}
						]
					},
					{
						"name": "D365BlobtoTableCurrency",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "ForEachAPI",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "JsonSource",
								"storeSettings": {
									"type": "AzureBlobStorageReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "JsonReadSettings"
								}
							},
							"sink": {
								"type": "AzureSqlSink",
								"writeBehavior": "insert",
								"sqlWriterUseTableLock": false,
								"tableOption": "autoCreate",
								"disableMetricsCollection": false
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"path": "[['transactioncurrencyid']"
										},
										"sink": {
											"name": "Transaction_Currency",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['currencyname']"
										},
										"sink": {
											"name": "Name",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['currencysymbol']"
										},
										"sink": {
											"name": "Symbol",
											"type": "String"
										}
									}
								],
								"collectionReference": "$['value']"
							}
						},
						"inputs": [
							{
								"referenceName": "ds_D365Output_json",
								"type": "DatasetReference",
								"parameters": {
									"FileName": {
										"value": "@concat('Currency',formatDateTime(convertTimeZone(utcNow(),'utc','E. Australia Standard Time'),'yyyyMMdd'))",
										"type": "Expression"
									}
								}
							}
						],
						"outputs": [
							{
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference",
								"parameters": {
									"Schema": {
										"value": "raw",
										"type": "Expression"
									},
									"TableName": {
										"value": "D365CRM_Currency",
										"type": "Expression"
									}
								}
							}
						]
					},
					{
						"name": "D365BlobtoTableFUMMovement",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "ForEachAPI",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "JsonSource",
								"storeSettings": {
									"type": "AzureBlobStorageReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "JsonReadSettings"
								}
							},
							"sink": {
								"type": "AzureSqlSink",
								"writeBehavior": "insert",
								"sqlWriterUseTableLock": false,
								"tableOption": "autoCreate",
								"disableMetricsCollection": false
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"path": "[['mcs_fummovementid']"
										},
										"sink": {
											"name": "FUM_Movement",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['_mcs_fum_value']"
										},
										"sink": {
											"name": "FUM",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['statuscode']"
										},
										"sink": {
											"name": "Status",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['_mcs_currency_value']"
										},
										"sink": {
											"name": "Currency",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['mcs_amount']"
										},
										"sink": {
											"name": "Amount",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['_mcs_movementtype_value']"
										},
										"sink": {
											"name": "Movement_Type",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['mcs_transactiontype']"
										},
										"sink": {
											"name": "Transaction_Type",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['mcs_note']"
										},
										"sink": {
											"name": "Note",
											"type": "String"
										}
									}
								],
								"collectionReference": "$['value']"
							}
						},
						"inputs": [
							{
								"referenceName": "ds_D365Output_json",
								"type": "DatasetReference",
								"parameters": {
									"FileName": {
										"value": "@concat('FUM Movement',formatDateTime(convertTimeZone(utcNow(),'utc','E. Australia Standard Time'),'yyyyMMdd'))",
										"type": "Expression"
									}
								}
							}
						],
						"outputs": [
							{
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference",
								"parameters": {
									"Schema": {
										"value": "raw",
										"type": "Expression"
									},
									"TableName": {
										"value": "D365CRM_FUMMovement",
										"type": "Expression"
									}
								}
							}
						]
					},
					{
						"name": "D365BlobtoTableFUM",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "ForEachAPI",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "JsonSource",
								"storeSettings": {
									"type": "AzureBlobStorageReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "JsonReadSettings"
								}
							},
							"sink": {
								"type": "AzureSqlSink",
								"writeBehavior": "insert",
								"sqlWriterUseTableLock": false,
								"tableOption": "autoCreate",
								"disableMetricsCollection": false
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"path": "[['mcs_fumid']"
										},
										"sink": {
											"name": "FUM",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['mcs_note']"
										},
										"sink": {
											"name": "Note",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['_mcs_asset_value']"
										},
										"sink": {
											"name": "Asset",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['mcs_periodclose']"
										},
										"sink": {
											"name": "Period_Close",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['statuscode']"
										},
										"sink": {
											"name": "Status_Reason",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['statecode']"
										},
										"sink": {
											"name": "Status",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['mcs_date']"
										},
										"sink": {
											"name": "Date",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['_mcs_consultant_value']"
										},
										"sink": {
											"name": "Consultant",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['mcs_type']"
										},
										"sink": {
											"name": "Type",
											"type": "String"
										}
									}
								],
								"collectionReference": "$['value']"
							}
						},
						"inputs": [
							{
								"referenceName": "ds_D365Output_json",
								"type": "DatasetReference",
								"parameters": {
									"FileName": {
										"value": "@concat('FUM',formatDateTime(convertTimeZone(utcNow(),'utc','E. Australia Standard Time'),'yyyyMMdd'))",
										"type": "Expression"
									}
								}
							}
						],
						"outputs": [
							{
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference",
								"parameters": {
									"Schema": {
										"value": "raw",
										"type": "Expression"
									},
									"TableName": {
										"value": "D365CRM_FUM",
										"type": "Expression"
									}
								}
							}
						]
					},
					{
						"name": "D365BlobtoTableMovementType",
						"type": "Copy",
						"dependsOn": [
							{
								"activity": "ForEachAPI",
								"dependencyConditions": [
									"Succeeded"
								]
							}
						],
						"policy": {
							"timeout": "7.00:00:00",
							"retry": 0,
							"retryIntervalInSeconds": 30,
							"secureOutput": false,
							"secureInput": false
						},
						"userProperties": [],
						"typeProperties": {
							"source": {
								"type": "JsonSource",
								"storeSettings": {
									"type": "AzureBlobStorageReadSettings",
									"recursive": true,
									"enablePartitionDiscovery": false
								},
								"formatSettings": {
									"type": "JsonReadSettings"
								}
							},
							"sink": {
								"type": "AzureSqlSink",
								"writeBehavior": "insert",
								"sqlWriterUseTableLock": false,
								"tableOption": "autoCreate",
								"disableMetricsCollection": false
							},
							"enableStaging": false,
							"translator": {
								"type": "TabularTranslator",
								"mappings": [
									{
										"source": {
											"path": "[['mcs_movementtypeid']"
										},
										"sink": {
											"name": "Movement_Type",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['statecode']"
										},
										"sink": {
											"name": "Status",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['statuscode']"
										},
										"sink": {
											"name": "Status_Reason",
											"type": "String"
										}
									},
									{
										"source": {
											"path": "[['mcs_name']"
										},
										"sink": {
											"name": "Name",
											"type": "String"
										}
									}
								],
								"collectionReference": "$['value']"
							}
						},
						"inputs": [
							{
								"referenceName": "ds_D365Output_json",
								"type": "DatasetReference",
								"parameters": {
									"FileName": {
										"value": "@concat('Movement Type',formatDateTime(convertTimeZone(utcNow(),'utc','E. Australia Standard Time'),'yyyyMMdd'))",
										"type": "Expression"
									}
								}
							}
						],
						"outputs": [
							{
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference",
								"parameters": {
									"Schema": {
										"value": "raw",
										"type": "Expression"
									},
									"TableName": {
										"value": "D365CRM_MovementType",
										"type": "Expression"
									}
								}
							}
						]
					}
				],
				"policy": {
					"elapsedTimeMetric": {},
					"cancelAfter": {}
				},
				"annotations": []
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/BudgetMappingtoDB')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "Update or insert budget mapping for source text and move source to archive",
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "BudgetMappingText",
								"type": "DatasetReference"
							},
							"name": "MappingText"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "relationalCOA_Views",
								"type": "DatasetReference"
							},
							"name": "COAViews"
						}
					],
					"transformations": [
						{
							"name": "AlterRow1"
						},
						{
							"name": "AuditFields"
						}
					],
					"script": "parameters{\n\tprocess_name as string,\n\tETL_local as string,\n\tuseremail as string\n}\nsource(output(\n\t\tView_Name as string,\n\t\tCategory_Index as integer,\n\t\tCategory as string,\n\t\tSub_Category_Index as integer,\n\t\tSub_Category as string,\n\t\tItem_Index as integer,\n\t\tItem as string,\n\t\tGL_Code as string,\n\t\tGL_Desc as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> MappingText\nAuditFields alterRow(upsertIf(true())) ~> AlterRow1\nMappingText derive(Update_Time = fromUTC(currentUTC(), 'Australia/Sydney'),\n\t\tProcess_Name = $process_name,\n\t\tUserEmail = $useremail) ~> AuditFields\nAlterRow1 sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tinput(\n\t\tGL_Code as string,\n\t\tGL_Desc as string,\n\t\tView_Name as string,\n\t\tCategory as string,\n\t\tprocess_name as string,\n\t\tSub_Category as string,\n\t\tItem as string,\n\t\tCategory_Index as integer,\n\t\tSub_Category_Index as integer,\n\t\tItem_Index as integer,\n\t\tCF_Code as string,\n\t\tCF_Description as string,\n\t\tCPM_Code as string,\n\t\tCPM_Description as string,\n\t\tupdate_datetime as timestamp,\n\t\tupdate_user as string\n\t),\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:false,\n\tupsertable:true,\n\tkeys:['View_Name','GL_Code'],\n\tformat: 'table',\n\tpostSQLs:['UPDATE relational.COA_Views\\nSET CPM_Code = COA.Reporting_5, GL_Desc = COA.GL_Desc\\n\\nFROM\\n\\nrelational.Chart_of_Account COA JOIN relational.COA_Views v on COA.GL_Code = v.GL_Code\\n\\nWHERE COA.record_deleted_flag = 0'],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tGL_Code,\n\t\tView_Name,\n\t\tCategory,\n\t\tprocess_name = Process_Name,\n\t\tSub_Category,\n\t\tItem,\n\t\tCategory_Index,\n\t\tSub_Category_Index,\n\t\tItem_Index,\n\t\tupdate_datetime = Update_Time,\n\t\tupdate_user = UserEmail\n\t)) ~> COAViews"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/DSOPEstate_DF')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "sums four columns from Estate sheet for each TM model",
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "DelimitedText_sourcelandingscrubbed_ds",
								"type": "DatasetReference"
							},
							"name": "ForestModel"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLstagingForecastData_ds",
								"type": "DatasetReference"
							},
							"name": "DBStaging"
						}
					],
					"transformations": [
						{
							"name": "ForestModelColumns"
						},
						{
							"name": "ColumnSums"
						},
						{
							"name": "AddStatus"
						},
						{
							"name": "NumericValues"
						},
						{
							"name": "Unpivot1"
						}
					],
					"script": "source(output(\n\t\tVersion as string,\n\t\tFund as string,\n\t\tAsset as string,\n\t\tPeriod as string,\n\t\tPlunitID as string,\n\t\tPlunit as string,\n\t\tOriginID as string,\n\t\tOrigin as string,\n\t\tSpeciesID as string,\n\t\tSpecies as string,\n\t\tPerpetualArea as string,\n\t\tCurrentArea as string,\n\t\tFutureArea as string,\n\t\tDisposed as string,\n\t\tAcquired as string,\n\t\tPerpetualFinalFell as string,\n\t\tCurrentFinalFell as string,\n\t\tFutureFinalFell as string,\n\t\tPerpetualLand as string,\n\t\tCurrentLand as string,\n\t\tFutureLand as string,\n\t\tPerpetualRental as string,\n\t\tCurrentRental as string,\n\t\tFutureRental as string,\n\t\tPerpetualOverhead as string,\n\t\tCurrentOverhead as string,\n\t\tFutureOverhead as string,\n\t\tPerpetualRates as string,\n\t\tCurrentRates as string,\n\t\tFutureRates as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> ForestModel\nForestModel select(mapColumn(\n\t\tVersion,\n\t\tFund,\n\t\tAsset,\n\t\tPeriod,\n\t\tPerpetualArea,\n\t\tPerpetualFinalFell,\n\t\tPerpetualLand,\n\t\tPerpetualRental,\n\t\tPerpetualOverhead,\n\t\tPerpetualRates\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> ForestModelColumns\nNumericValues aggregate(groupBy(Version,\n\t\tFund,\n\t\tAsset,\n\t\tPeriod),\n\tPerpetualArea = sum(PerpetualArea),\n\t\tPerpetualFinalFell = sum(PerpetualFinalFell),\n\t\tPerpetualLand = sum(PerpetualLand),\n\t\tPerpetualRental = sum(PerpetualRental),\n\t\tPerpetualOverhead = sum(PerpetualOverhead),\n\t\tPerpetualRates = sum(PerpetualRates)) ~> ColumnSums\nUnpivot1 derive(Status = 'Estate_Calcs') ~> AddStatus\nForestModelColumns derive(PerpetualArea = toDouble(PerpetualArea),\n\t\tPerpetualFinalFell = toDouble(PerpetualFinalFell),\n\t\tPerpetualLand = toDouble(PerpetualLand),\n\t\tPerpetualRental = toDouble(PerpetualRental),\n\t\tPerpetualOverhead = toDouble(PerpetualOverhead),\n\t\tPerpetualRates = toDouble(PerpetualRates)) ~> NumericValues\nColumnSums unpivot(output(\n\t\tProduct as string,\n\t\tPerpetual as double\n\t),\n\tungroupBy(Version,\n\t\tFund,\n\t\tAsset,\n\t\tPeriod),\n\tlateral: false,\n\tignoreNullPivots: true) ~> Unpivot1\nAddStatus sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tinput(\n\t\tPeriod as string,\n\t\tStatus as string,\n\t\tProduct as string,\n\t\tPerpetual_Amount as string,\n\t\tCurent_Amount as string,\n\t\tFuture_Amount as string,\n\t\tFund_ID as string,\n\t\tAsset_ID as string,\n\t\tVersion_name as string,\n\t\tUOM as string,\n\t\tShare_Perpetual as string,\n\t\tEntity as string,\n\t\tDestination as string,\n\t\tCategory as string\n\t),\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tPeriod,\n\t\tStatus,\n\t\tProduct,\n\t\tPerpetual_Amount = Perpetual,\n\t\tFund_ID = Fund,\n\t\tAsset_ID = Asset,\n\t\tVersion_name = Version\n\t)) ~> DBStaging"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadMktDimDataSource_InsertUpdate_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "CSVgenericWithParameter_ds",
								"type": "DatasetReference"
							},
							"name": "ReadSource"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGeneric_ds",
								"type": "DatasetReference"
							},
							"name": "DatamartDimDataSourceLkp"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "TargetDim"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "ErrorTable"
						}
					],
					"transformations": [
						{
							"name": "SelectDimDataSourceLkp"
						},
						{
							"name": "DataTransformation"
						},
						{
							"name": "CheckDimensionRecordExist"
						},
						{
							"name": "AddAdditionalAudit"
						},
						{
							"name": "AlterRowInsertUpdate"
						},
						{
							"name": "CheckInputRecord"
						},
						{
							"name": "AddErrorDetail"
						},
						{
							"name": "RemoveBlankRow"
						},
						{
							"name": "GetNewOrModified"
						},
						{
							"name": "RemoveDuplicate"
						},
						{
							"name": "ReplaceNullToUndefined"
						}
					],
					"script": "parameters{\n\tGeneratedBatchDate as string,\n\tWorkbookName as string,\n\tWorksheetName as string,\n\tMasterPipelineName as string\n}\nsource(output(\n\t\t{Source Metric} as string,\n\t\t{Source Name} as string,\n\t\t{Source Type} as string,\n\t\t{Source Link} as string,\n\t\t{Source Data Type} as string,\n\t\t{Data Process Type} as string,\n\t\t{Source Status} as string,\n\t\tFrequency as string,\n\t\t{Confidence Level} as string,\n\t\t{Person Responsible} as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> ReadSource\nsource(output(\n\t\tMetric_Short_Name as string,\n\t\tSource_Name as string,\n\t\tSource_Type as string,\n\t\tSource_Link as string,\n\t\tSource_Data_Type as string,\n\t\tData_Process_Type as string,\n\t\tSource_Status as string,\n\t\tFrequency as string,\n\t\tConfidence_Level as string,\n\t\tPerson_Responsible as string,\n\t\tInsert_DateTime as timestamp\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT DISTINCT\\n       [Metric_Short_Name]\\n      ,[Source_Name]\\n      ,[Source_Type]\\n      ,[Source_Link]\\n      ,[Source_Data_Type]\\n      ,[Data_Process_Type]\\n      ,[Source_Status]\\n      ,[Frequency]\\n      ,[Confidence_Level]\\n      ,[Person_Responsible]\\n      ,[Insert_DateTime]\\nFROM [datamart].[Dim_Data_Source]\\nWHERE Data_Source_Id != -1',\n\tformat: 'query') ~> DatamartDimDataSourceLkp\nDatamartDimDataSourceLkp select(mapColumn(\n\t\tMetric_Short_Name_Lkp = Metric_Short_Name,\n\t\tSource_Name_Lkp = Source_Name,\n\t\tSource_Type_Lkp = Source_Type,\n\t\tSource_Link_Lkp = Source_Link,\n\t\tSource_Data_Type_Lkp = Source_Data_Type,\n\t\tData_Process_Type_Lkp = Data_Process_Type,\n\t\tSource_Status_Lkp = Source_Status,\n\t\tFrequency_Lkp = Frequency,\n\t\tConfidence_Level_Lkp = Confidence_Level,\n\t\tPerson_Responsible_Lkp = Person_Responsible,\n\t\tInsert_DateTime_Lkp = Insert_DateTime\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectDimDataSourceLkp\nReadSource derive(Source_File = concat($WorkbookName,'-', $WorksheetName),\n\t\tBatch_ID = replace(replace(replace($GeneratedBatchDate, \"-\", \"\"),\":\",\"\"),\" \",\"\"),\n\t\tProcess_Name = $MasterPipelineName) ~> DataTransformation\nRemoveDuplicate, SelectDimDataSourceLkp lookup({Source Metric} == Metric_Short_Name_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> CheckDimensionRecordExist\nGetNewOrModified derive(InsertUpdateFlag = iif(isNull(Metric_Short_Name_Lkp), \"I\", \"U\"),\n\t\tInsert_DateTime = iif(isNull(Metric_Short_Name_Lkp), fromUTC(currentUTC(), 'Australia/Sydney'), Insert_DateTime_Lkp),\n\t\tUpdate_DateTime = iif(isNull(Metric_Short_Name_Lkp), toTimestamp(\"\"), fromUTC(currentUTC(), 'Australia/Sydney'))) ~> AddAdditionalAudit\nAddAdditionalAudit alterRow(insertIf(equals(InsertUpdateFlag,\"I\")),\n\tupdateIf(equals(InsertUpdateFlag,\"U\"))) ~> AlterRowInsertUpdate\nDataTransformation split(not(isNull({Source Metric})),\n\tdisjoint: false) ~> CheckInputRecord@(Valid, Invalid)\nRemoveBlankRow derive(Error_Desc = toString(\"Source Metric cannot be empty\"),\n\t\tInsert_Datetime = fromUTC(currentUTC(), 'Australia/Sydney')) ~> AddErrorDetail\nCheckInputRecord@Invalid filter(not(isNull({Source Metric})) || not(isNull({Source Name})) || not(isNull({Source Type})) || not(isNull({Source Link})) || \r\nnot(isNull({Source Data Type})) || not(isNull({Data Process Type})) || not(isNull({Source Status})) || not(isNull(Frequency)) || \r\nnot(isNull({Confidence Level})) || not(isNull({Person Responsible}))) ~> RemoveBlankRow\nCheckDimensionRecordExist filter(isNull(Metric_Short_Name_Lkp) || \r\nnotEquals({Source Name}, Source_Name_Lkp) || \r\nnotEquals({Source Type}, Source_Type_Lkp) || \r\nnotEquals({Source Link}, Source_Link_Lkp) || \r\nnotEquals({Source Data Type}, Source_Data_Type_Lkp) || \r\nnotEquals({Data Process Type}, Data_Process_Type_Lkp) || \r\nnotEquals({Source Status}, Source_Status_Lkp) || \r\nnotEquals(Frequency, Frequency_Lkp) || \r\nnotEquals({Confidence Level}, Confidence_Level_Lkp) || \r\nnotEquals({Person Responsible}, Person_Responsible_Lkp)) ~> GetNewOrModified\nReplaceNullToUndefined aggregate(groupBy({Source Metric},\n\t\t{Source Name},\n\t\t{Source Type},\n\t\t{Source Link},\n\t\t{Source Data Type},\n\t\t{Data Process Type},\n\t\t{Source Status},\n\t\tFrequency,\n\t\t{Confidence Level},\n\t\t{Person Responsible},\n\t\tSource_File,\n\t\tBatch_ID,\n\t\tProcess_Name),\n\tDuplicateCount = count()) ~> RemoveDuplicate\nCheckInputRecord@Valid derive({Source Name} = iifNull({Source Name}, \"Undefined\"),\n\t\t{Source Type} = iifNull({Source Type}, \"Undefined\"),\n\t\t{Source Link} = iifNull({Source Link}, \"Undefined\"),\n\t\t{Source Data Type} = iifNull({Source Data Type}, \"Undefined\"),\n\t\t{Data Process Type} = iifNull({Data Process Type}, \"Undefined\"),\n\t\t{Source Status} = iifNull({Source Status}, \"Undefined\"),\n\t\tFrequency = iifNull(Frequency, \"Undefined\"),\n\t\t{Confidence Level} = iifNull({Confidence Level}, \"Undefined\"),\n\t\t{Person Responsible} = iifNull({Person Responsible}, \"Undefined\")) ~> ReplaceNullToUndefined\nAlterRowInsertUpdate sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['Metric_Short_Name'],\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tMetric_Short_Name = {Source Metric},\n\t\tSource_Name = {Source Name},\n\t\tSource_Type = {Source Type},\n\t\tSource_Link = {Source Link},\n\t\tSource_Data_Type = {Source Data Type},\n\t\tData_Process_Type = {Data Process Type},\n\t\tSource_Status = {Source Status},\n\t\tFrequency,\n\t\tConfidence_Level = {Confidence Level},\n\t\tPerson_Responsible = {Person Responsible},\n\t\tSource_File,\n\t\tBatch_ID,\n\t\tProcess_Name,\n\t\tInsert_DateTime,\n\t\tUpdate_DateTime\n\t),\n\tpartitionBy('hash', 1)) ~> TargetDim\nAddErrorDetail sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tMetric_Short_Name = {Source Metric},\n\t\tSource_Name = {Source Name},\n\t\tSource_Type = {Source Type},\n\t\tSource_Link = {Source Link},\n\t\tSource_Data_Type = {Source Data Type},\n\t\tData_Process_Type = {Data Process Type},\n\t\tSource_Status = {Source Status},\n\t\tFrequency,\n\t\tConfidence_Level = {Confidence Level},\n\t\tPerson_Responsible = {Person Responsible},\n\t\tSource_File,\n\t\tProcess_Name,\n\t\tError_Desc,\n\t\tInsert_Datetime\n\t)) ~> ErrorTable"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadMktDimDeliveryPoint_InsertUpdate_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "CSVgenericWithParameter_ds",
								"type": "DatasetReference"
							},
							"name": "ReadSource"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGeneric_ds",
								"type": "DatasetReference"
							},
							"name": "RelationalDimDeliveryPointLkp"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "TargetDim"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "ErrorTable"
						}
					],
					"transformations": [
						{
							"name": "SelectDimDeliveryPointLkp"
						},
						{
							"name": "DataTransformation"
						},
						{
							"name": "CheckDimensionRecordExist"
						},
						{
							"name": "AddAdditionalAudit"
						},
						{
							"name": "AlterRowInsertUpdate"
						},
						{
							"name": "CheckInputRecord"
						},
						{
							"name": "AddErrorDetail"
						},
						{
							"name": "RemoveBlankRow"
						},
						{
							"name": "GetNewOrModified"
						},
						{
							"name": "RemoveDuplicate"
						},
						{
							"name": "ReplaceNullToUndefined"
						}
					],
					"script": "parameters{\n\tGeneratedBatchDate as string,\n\tWorkbookName as string,\n\tWorksheetName as string,\n\tMasterPipelineName as string\n}\nsource(output(\n\t\t{Deliver Point Code} as string,\n\t\t{Delivery Point} as string,\n\t\t{Delivery Point Desc} as string,\n\t\t{Delivery Point Long Desc} as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> ReadSource\nsource(output(\n\t\tDeliver_Point_Code as string,\n\t\tDelivery_Point as string,\n\t\tDelivery_Point_Desc as string,\n\t\tDelivery_Point_Long_Desc as string,\n\t\tInsert_DateTime as timestamp\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT DISTINCT\\n       [Deliver_Point_Code]\\n      ,[Delivery_Point]\\n      ,[Delivery_Point_Desc]\\n      ,[Delivery_Point_Long_Desc]\\n      ,[Insert_DateTime]\\nFROM [datamart].[Dim_Delivery_Point]\\nWHERE Delivery_Point_ID != -1',\n\tformat: 'query') ~> RelationalDimDeliveryPointLkp\nRelationalDimDeliveryPointLkp select(mapColumn(\n\t\tDeliver_Point_Code_Lkp = Deliver_Point_Code,\n\t\tDelivery_Point_Lkp = Delivery_Point,\n\t\tDelivery_Point_Desc_Lkp = Delivery_Point_Desc,\n\t\tDelivery_Point_Long_Desc_Lkp = Delivery_Point_Long_Desc,\n\t\tInsert_DateTime_Lkp = Insert_DateTime\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectDimDeliveryPointLkp\nReadSource derive(Source_File = concat($WorkbookName,'-', $WorksheetName),\n\t\tBatch_ID = replace(replace(replace($GeneratedBatchDate, \"-\", \"\"),\":\",\"\"),\" \",\"\"),\n\t\tProcess_Name = $MasterPipelineName) ~> DataTransformation\nRemoveDuplicate, SelectDimDeliveryPointLkp lookup({Deliver Point Code} == Deliver_Point_Code_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> CheckDimensionRecordExist\nGetNewOrModified derive(InsertUpdateFlag = iif(isNull(Deliver_Point_Code_Lkp), \"I\", \"U\"),\n\t\tInsert_DateTime = iif(isNull(Deliver_Point_Code_Lkp), fromUTC(currentUTC(), 'Australia/Sydney'), Insert_DateTime_Lkp),\n\t\tUpdate_DateTime = iif(isNull(Deliver_Point_Code_Lkp), toTimestamp(\"\"), fromUTC(currentUTC(), 'Australia/Sydney'))) ~> AddAdditionalAudit\nAddAdditionalAudit alterRow(insertIf(equals(InsertUpdateFlag,\"I\")),\n\tupdateIf(equals(InsertUpdateFlag,\"U\"))) ~> AlterRowInsertUpdate\nDataTransformation split(not(isNull({Deliver Point Code})),\n\tdisjoint: false) ~> CheckInputRecord@(Valid, Invalid)\nRemoveBlankRow derive(Error_Desc = toString(\"Delivery Point Code cannot be empty\"),\n\t\tInsert_Datetime = fromUTC(currentUTC(), 'Australia/Sydney')) ~> AddErrorDetail\nCheckInputRecord@Invalid filter(not(isNull({Deliver Point Code})) || not(isNull({Delivery Point})) || \r\nnot(isNull({Delivery Point Desc})) || not(isNull({Delivery Point Long Desc}))) ~> RemoveBlankRow\nCheckDimensionRecordExist filter(isNull(Deliver_Point_Code_Lkp) || \r\nnotEquals({Delivery Point}, Delivery_Point_Lkp) || \r\nnotEquals({Delivery Point Desc}, Delivery_Point_Desc_Lkp) || \r\nnotEquals({Delivery Point Long Desc}, Delivery_Point_Long_Desc_Lkp)) ~> GetNewOrModified\nReplaceNullToUndefined aggregate(groupBy({Deliver Point Code},\n\t\t{Delivery Point},\n\t\t{Delivery Point Desc},\n\t\t{Delivery Point Long Desc},\n\t\tSource_File,\n\t\tBatch_ID,\n\t\tProcess_Name),\n\tDuplicateCount = count()) ~> RemoveDuplicate\nCheckInputRecord@Valid derive({Delivery Point} = iifNull({Delivery Point}, \"Undefined\"),\n\t\t{Delivery Point Desc} = iifNull({Delivery Point Desc}, \"Undefined\"),\n\t\t{Delivery Point Long Desc} = iifNull({Delivery Point Long Desc}, \"Undefined\")) ~> ReplaceNullToUndefined\nAlterRowInsertUpdate sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['Deliver_Point_Code'],\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tDeliver_Point_Code = {Deliver Point Code},\n\t\tDelivery_Point = {Delivery Point},\n\t\tDelivery_Point_Desc = {Delivery Point Desc},\n\t\tDelivery_Point_Long_Desc = {Delivery Point Long Desc},\n\t\tSource_File,\n\t\tBatch_ID,\n\t\tProcess_Name,\n\t\tInsert_DateTime,\n\t\tUpdate_DateTime\n\t),\n\tpartitionBy('hash', 1)) ~> TargetDim\nAddErrorDetail sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tDeliver_Point_Code = {Deliver Point Code},\n\t\tDelivery_Point = {Delivery Point},\n\t\tDelivery_Point_Desc = {Delivery Point Desc},\n\t\tDelivery_Point_Long_Desc = {Delivery Point Long Desc},\n\t\tSource_File,\n\t\tProcess_Name,\n\t\tError_Desc,\n\t\tInsert_Datetime\n\t)) ~> ErrorTable"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadMktDimIndicator_InsertUpdate_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "CSVgenericWithParameter_ds",
								"type": "DatasetReference"
							},
							"name": "ReadSource"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGeneric_ds",
								"type": "DatasetReference"
							},
							"name": "DatamartDimIndicatorLkp"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "TargetDim"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "ErrorTable"
						}
					],
					"transformations": [
						{
							"name": "SelectDimIndicatorLkp"
						},
						{
							"name": "DataTransformation"
						},
						{
							"name": "CheckDimensionRecordExist"
						},
						{
							"name": "AddAdditionalAudit"
						},
						{
							"name": "AlterRowInsertUpdate"
						},
						{
							"name": "CheckInputRecord"
						},
						{
							"name": "AddErrorDetail"
						},
						{
							"name": "RemoveBlankRow"
						},
						{
							"name": "GetNewOrModified"
						},
						{
							"name": "RemoveDuplicate"
						},
						{
							"name": "ReplaceNullToUndefined"
						}
					],
					"script": "parameters{\n\tGeneratedBatchDate as string,\n\tWorkbookName as string,\n\tWorksheetName as string,\n\tMasterPipelineName as string\n}\nsource(output(\n\t\t{Indicator Code} as string,\n\t\t{Indicator Desc} as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> ReadSource\nsource(output(\n\t\tIndicator_Code as string,\n\t\tIndicator_Desc as string,\n\t\tInsert_DateTime as timestamp\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT DISTINCT \\n       [Indicator_Code]\\n      ,[Indicator_Desc]\\n      ,[Insert_DateTime]\\n  FROM [datamart].[Dim_Indicator]\\nWHERE Indicator_Id != -1',\n\tformat: 'query') ~> DatamartDimIndicatorLkp\nDatamartDimIndicatorLkp select(mapColumn(\n\t\tIndicator_Code_Lkp = Indicator_Code,\n\t\tIndicator_Desc_Lkp = Indicator_Desc,\n\t\tInsert_DateTime_Lkp = Insert_DateTime\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectDimIndicatorLkp\nReadSource derive(Source_File = concat($WorkbookName,'-', $WorksheetName),\n\t\tBatch_ID = replace(replace(replace($GeneratedBatchDate, \"-\", \"\"),\":\",\"\"),\" \",\"\"),\n\t\tProcess_Name = $MasterPipelineName) ~> DataTransformation\nRemoveDuplicate, SelectDimIndicatorLkp lookup({Indicator Code} == Indicator_Code_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> CheckDimensionRecordExist\nGetNewOrModified derive(InsertUpdateFlag = iif(isNull(Indicator_Code_Lkp), \"I\", \"U\"),\n\t\tInsert_DateTime = iif(isNull(Indicator_Code_Lkp), fromUTC(currentUTC(), 'Australia/Sydney'), Insert_DateTime_Lkp),\n\t\tUpdate_DateTime = iif(isNull(Indicator_Code_Lkp), toTimestamp(\"\"), fromUTC(currentUTC(), 'Australia/Sydney'))) ~> AddAdditionalAudit\nAddAdditionalAudit alterRow(insertIf(equals(InsertUpdateFlag,\"I\")),\n\tupdateIf(equals(InsertUpdateFlag,\"U\"))) ~> AlterRowInsertUpdate\nDataTransformation split(not(isNull({Indicator Code})),\n\tdisjoint: false) ~> CheckInputRecord@(Valid, Invalid)\nRemoveBlankRow derive(Error_Desc = toString(\"Indicator Code cannot be empty\"),\n\t\tInsert_Datetime = fromUTC(currentUTC(), 'Australia/Sydney')) ~> AddErrorDetail\nCheckInputRecord@Invalid filter(not(isNull({Indicator Code})) || not(isNull({Indicator Desc}))) ~> RemoveBlankRow\nCheckDimensionRecordExist filter(isNull(Indicator_Code_Lkp) || notEquals({Indicator Desc}, Indicator_Desc_Lkp)) ~> GetNewOrModified\nReplaceNullToUndefined aggregate(groupBy({Indicator Code},\n\t\t{Indicator Desc},\n\t\tSource_File,\n\t\tBatch_ID,\n\t\tProcess_Name),\n\tDuplicateCount = count()) ~> RemoveDuplicate\nCheckInputRecord@Valid derive({Indicator Desc} = iifNull({Indicator Desc}, \"Undefined\")) ~> ReplaceNullToUndefined\nAlterRowInsertUpdate sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['Indicator_Code'],\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tIndicator_Code = {Indicator Code},\n\t\tIndicator_Desc = {Indicator Desc},\n\t\tSource_File,\n\t\tBatch_ID,\n\t\tProcess_Name,\n\t\tInsert_DateTime,\n\t\tUpdate_DateTime\n\t),\n\tpartitionBy('hash', 1)) ~> TargetDim\nAddErrorDetail sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tIndicator_Code = {Indicator Code},\n\t\tIndicator_Desc = {Indicator Desc},\n\t\tSource_File,\n\t\tProcess_Name,\n\t\tError_Desc,\n\t\tInsert_Datetime\n\t)) ~> ErrorTable"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadMktDimProduct_InsertUpdate_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "CSVgenericWithParameter_ds",
								"type": "DatasetReference"
							},
							"name": "ReadSource"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGeneric_ds",
								"type": "DatasetReference"
							},
							"name": "DatamartDimProductLkp"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGeneric_ds",
								"type": "DatasetReference"
							},
							"name": "DatamartSpeciesLkp"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGeneric_ds",
								"type": "DatasetReference"
							},
							"name": "RelationalChartOfAccountLkp"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "TargetDim"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "ErrorTable"
						}
					],
					"transformations": [
						{
							"name": "SelectDimProductLkp"
						},
						{
							"name": "DataTransformation"
						},
						{
							"name": "CheckDimensionRecordExist"
						},
						{
							"name": "AddAdditionalAudit"
						},
						{
							"name": "AlterRowInsertUpdate"
						},
						{
							"name": "CheckInputRecord"
						},
						{
							"name": "AddErrorDetail"
						},
						{
							"name": "RemoveBlankRow"
						},
						{
							"name": "GetNewOrModified"
						},
						{
							"name": "RemoveDuplicate"
						},
						{
							"name": "ReplaceNullToUndefined"
						},
						{
							"name": "SelectDimSpeciesLkp"
						},
						{
							"name": "SelectRelationalCoaLkp"
						},
						{
							"name": "LookupDimSpecies"
						},
						{
							"name": "LookupChartOfAccount"
						}
					],
					"script": "parameters{\n\tGeneratedBatchDate as string,\n\tWorkbookName as string,\n\tWorksheetName as string,\n\tMasterPipelineName as string\n}\nsource(output(\n\t\t{Product Code} as string,\n\t\t{Product Type} as string,\n\t\t{Product Global Grade} as string,\n\t\t{Product Desc} as string,\n\t\t{GL Code} as string,\n\t\t{Species Code} as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> ReadSource\nsource(output(\n\t\tProduct_Code as string,\n\t\tProduct_Type as string,\n\t\tProduct_Global_Grade as string,\n\t\tProduct_Desc as string,\n\t\tGL_Code as string,\n\t\tSpecies_Code as string,\n\t\tInsert_DateTime as timestamp\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT DISTINCT \\n       [Product_Code]\\n      ,[Product_Type]\\n      ,[Product_Global_Grade]\\n      ,[Product_Desc]\\n      ,[GL_Code]\\n      ,[Species_Code]\\n      ,[Insert_DateTime]\\nFROM [datamart].[Dim_Product]\\nWHERE Product_Id != -1',\n\tformat: 'query') ~> DatamartDimProductLkp\nsource(output(\n\t\tSpecies_Code as string,\n\t\tSpecies as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT DISTINCT \\n       [Species_Code]\\n      ,[Species]\\nFROM [datamart].[Dim_Species]\\nWHERE Species_ID != -1',\n\tformat: 'query') ~> DatamartSpeciesLkp\nsource(output(\n\t\tGL_Code as string,\n\t\tGL_Desc as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT DISTINCT \\n       [GL_Code]\\n      ,[GL_Desc]\\n  FROM [relational].[Chart_of_Account] \\n  WHERE GL_Code != \\'\\' \\n  AND [record_deleted_flag] = 0\\n  AND [end_datetime] = \\'9999-12-31 00:00:00.000\\'',\n\tformat: 'query') ~> RelationalChartOfAccountLkp\nDatamartDimProductLkp select(mapColumn(\n\t\tProduct_Code_Lkp = Product_Code,\n\t\tProduct_Type_Lkp = Product_Type,\n\t\tProduct_Global_Grade_Lkp = Product_Global_Grade,\n\t\tProduct_Desc_Lkp = Product_Desc,\n\t\tGL_Code_Lkp = GL_Code,\n\t\tSpecies_Code_Lkp = Species_Code,\n\t\tInsert_DateTime_Lkp = Insert_DateTime\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectDimProductLkp\nReadSource derive(Source_File = concat($WorkbookName,'-', $WorksheetName),\n\t\tBatch_ID = replace(replace(replace($GeneratedBatchDate, \"-\", \"\"),\":\",\"\"),\" \",\"\"),\n\t\tProcess_Name = $MasterPipelineName) ~> DataTransformation\nRemoveDuplicate, SelectDimProductLkp lookup({Product Code} == Product_Code_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> CheckDimensionRecordExist\nGetNewOrModified derive(InsertUpdateFlag = iif(isNull(Product_Code_Lkp), \"I\", \"U\"),\n\t\tInsert_DateTime = iif(isNull(Product_Code_Lkp), fromUTC(currentUTC(), 'Australia/Sydney'), Insert_DateTime_Lkp),\n\t\tUpdate_DateTime = iif(isNull(Product_Code_Lkp), toTimestamp(\"\"), fromUTC(currentUTC(), 'Australia/Sydney'))) ~> AddAdditionalAudit\nAddAdditionalAudit alterRow(insertIf(equals(InsertUpdateFlag,\"I\")),\n\tupdateIf(equals(InsertUpdateFlag,\"U\"))) ~> AlterRowInsertUpdate\nLookupChartOfAccount split(not(isNull({Product Code})) && \r\n(isNull({Species Code}) || not(isNull(Species_Code_Lkp))) &&\r\n(isNull({GL Code}) || not(isNull(GL_Code_Lkp))),\n\tdisjoint: false) ~> CheckInputRecord@(Valid, Invalid)\nRemoveBlankRow derive(Error_Desc = toString(\"Product Code cannot be empty or Invalid GL Code or Invalid Species Code\"),\n\t\tInsert_Datetime = fromUTC(currentUTC(), 'Australia/Sydney')) ~> AddErrorDetail\nCheckInputRecord@Invalid filter(not(isNull({Product Code})) || not(isNull({Product Type})) || not(isNull({Product Global Grade})) || \r\nnot(isNull({Product Desc})) || not(isNull({GL Code})) || not(isNull({Species Code}))) ~> RemoveBlankRow\nCheckDimensionRecordExist filter(isNull(Product_Code_Lkp) || \r\nnotEquals({Product Type}, Product_Type_Lkp) || \r\nnotEquals({Product Global Grade}, Product_Global_Grade_Lkp) || \r\nnotEquals({Product Desc}, Product_Desc_Lkp) || \r\nnotEquals({GL Code}, GL_Code_Lkp) || \r\nnotEquals({Species Code}, Species_Code_Lkp)) ~> GetNewOrModified\nReplaceNullToUndefined aggregate(groupBy({Product Code},\n\t\t{Product Type},\n\t\t{Product Global Grade},\n\t\t{Product Desc},\n\t\t{GL Code},\n\t\t{Species Code},\n\t\tSource_File,\n\t\tBatch_ID,\n\t\tProcess_Name),\n\tDuplicateCount = count()) ~> RemoveDuplicate\nCheckInputRecord@Valid derive({Product Type} = iifNull({Product Type}, \"Undefined\"),\n\t\t{Product Desc} = iifNull({Product Desc}, \"Undefined\"),\n\t\t{Product Global Grade} = iifNull({Product Global Grade}, \"Undefined\"),\n\t\t{GL Code} = iifNull({GL Code}, \"Undefined\"),\n\t\t{Species Code} = iifNull({Species Code}, \"Undefined\")) ~> ReplaceNullToUndefined\nDatamartSpeciesLkp select(mapColumn(\n\t\tSpecies_Code_Lkp = Species_Code,\n\t\tSpecies_Lkp = Species\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectDimSpeciesLkp\nRelationalChartOfAccountLkp select(mapColumn(\n\t\tGL_Code_Lkp = GL_Code,\n\t\tGL_Desc_Lkp = GL_Desc\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectRelationalCoaLkp\nDataTransformation, SelectDimSpeciesLkp lookup({Species Code} == Species_Code_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupDimSpecies\nLookupDimSpecies, SelectRelationalCoaLkp lookup({GL Code} == GL_Code_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupChartOfAccount\nAlterRowInsertUpdate sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['Species_Code'],\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tProduct_Code = {Product Code},\n\t\tProduct_Type = {Product Type},\n\t\tProduct_Global_Grade = {Product Global Grade},\n\t\tProduct_Desc = {Product Desc},\n\t\tGL_Code = {GL Code},\n\t\tSpecies_Code = {Species Code},\n\t\tSource_File,\n\t\tBatch_ID,\n\t\tProcess_Name,\n\t\tInsert_DateTime,\n\t\tUpdate_DateTime\n\t),\n\tpartitionBy('hash', 1)) ~> TargetDim\nAddErrorDetail sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tProduct_Code = {Product Code},\n\t\tProduct_Type = {Product Type},\n\t\tProduct_Global_Grade = {Product Global Grade},\n\t\tProduct_Desc = {Product Desc},\n\t\tGL_Code = {GL Code},\n\t\tSpecies_Code = {Species Code},\n\t\tSource_File,\n\t\tProcess_Name,\n\t\tError_Desc,\n\t\tInsert_Datetime\n\t)) ~> ErrorTable"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadMktDimSpecies_InsertUpdate_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "CSVgenericWithParameter_ds",
								"type": "DatasetReference"
							},
							"name": "ReadSource"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGeneric_ds",
								"type": "DatasetReference"
							},
							"name": "DatamartDimSpeciesLkp"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "TargetDim"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "ErrorTable"
						}
					],
					"transformations": [
						{
							"name": "SelectDimSpeciesLkp"
						},
						{
							"name": "DataTransformation"
						},
						{
							"name": "CheckDimensionRecordExist"
						},
						{
							"name": "AddAdditionalAudit"
						},
						{
							"name": "AlterRowInsertUpdate"
						},
						{
							"name": "CheckInputRecord"
						},
						{
							"name": "AddErrorDetail"
						},
						{
							"name": "RemoveBlankRow"
						},
						{
							"name": "GetNewOrModified"
						},
						{
							"name": "RemoveDuplicate"
						},
						{
							"name": "ReplaceNullToUndefined"
						}
					],
					"script": "parameters{\n\tGeneratedBatchDate as string,\n\tWorkbookName as string,\n\tWorksheetName as string,\n\tMasterPipelineName as string\n}\nsource(output(\n\t\t{Species Code} as string,\n\t\t{Species Desc} as string,\n\t\tGenus as string,\n\t\t{Species Group} as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> ReadSource\nsource(output(\n\t\tSpecies_Code as string,\n\t\tSpecies as string,\n\t\tGenus as string,\n\t\tSpecies_Group as string,\n\t\tInsert_DateTime as timestamp\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT DISTINCT [Species_Code]\\n      ,[Species]\\n      ,[Genus]\\n      ,[Species_Group]\\n      ,[Insert_DateTime]\\n FROM [datamart].[Dim_Species]\\nWHERE Species_ID != -1',\n\tformat: 'query') ~> DatamartDimSpeciesLkp\nDatamartDimSpeciesLkp select(mapColumn(\n\t\tSpecies_Code_Lkp = Species_Code,\n\t\tSpecies_Lkp = Species,\n\t\tGenus_Lkp = Genus,\n\t\tSpecies_Group_Lkp = Species_Group,\n\t\tInsert_DateTime_Lkp = Insert_DateTime\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectDimSpeciesLkp\nReadSource derive(Source_File = concat($WorkbookName,'-', $WorksheetName),\n\t\tBatch_ID = replace(replace(replace($GeneratedBatchDate, \"-\", \"\"),\":\",\"\"),\" \",\"\"),\n\t\tProcess_Name = $MasterPipelineName) ~> DataTransformation\nRemoveDuplicate, SelectDimSpeciesLkp lookup({Species Code} == Species_Code_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> CheckDimensionRecordExist\nGetNewOrModified derive(InsertUpdateFlag = iif(isNull(Species_Code_Lkp), \"I\", \"U\"),\n\t\tInsert_DateTime = iif(isNull(Species_Code_Lkp), fromUTC(currentUTC(), 'Australia/Sydney'), Insert_DateTime_Lkp),\n\t\tUpdate_DateTime = iif(isNull(Species_Code_Lkp), toTimestamp(\"\"), fromUTC(currentUTC(), 'Australia/Sydney'))) ~> AddAdditionalAudit\nAddAdditionalAudit alterRow(insertIf(equals(InsertUpdateFlag,\"I\")),\n\tupdateIf(equals(InsertUpdateFlag,\"U\"))) ~> AlterRowInsertUpdate\nDataTransformation split(not(isNull({Species Code})),\n\tdisjoint: false) ~> CheckInputRecord@(Valid, Invalid)\nRemoveBlankRow derive(Error_Desc = toString(\"Species Code cannot be empty\"),\n\t\tInsert_Datetime = fromUTC(currentUTC(), 'Australia/Sydney')) ~> AddErrorDetail\nCheckInputRecord@Invalid filter(not(isNull({Species Code})) || not(isNull({Species Desc})) || not(isNull(Genus)) || not(isNull({Species Group}))) ~> RemoveBlankRow\nCheckDimensionRecordExist filter(isNull(Species_Code_Lkp) || \r\nnotEquals({Species Desc}, Species_Lkp) || notEquals(Genus, Genus_Lkp) || notEquals({Species Group}, Species_Group_Lkp)) ~> GetNewOrModified\nReplaceNullToUndefined aggregate(groupBy({Species Code},\n\t\t{Species Desc},\n\t\tGenus,\n\t\t{Species Group},\n\t\tSource_File,\n\t\tBatch_ID,\n\t\tProcess_Name),\n\tDuplicateCount = count()) ~> RemoveDuplicate\nCheckInputRecord@Valid derive({Species Desc} = iifNull({Species Desc}, \"Undefined\"),\n\t\tGenus = iifNull(Genus, \"Undefined\"),\n\t\t{Species Group} = iifNull({Species Group}, \"Undefined\")) ~> ReplaceNullToUndefined\nAlterRowInsertUpdate sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['Species_Code'],\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tSpecies_Code = {Species Code},\n\t\tSpecies = {Species Desc},\n\t\tGenus,\n\t\tSpecies_Group = {Species Group},\n\t\tSource_File,\n\t\tBatch_ID,\n\t\tProcess_Name,\n\t\tInsert_DateTime,\n\t\tUpdate_DateTime\n\t),\n\tpartitionBy('hash', 1)) ~> TargetDim\nAddErrorDetail sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tSpecies_Code = {Species Code},\n\t\tSpecies = {Species Desc},\n\t\tGenus,\n\t\tSpecies_Group = {Species Group},\n\t\tSource_File,\n\t\tProcess_Name,\n\t\tError_Desc,\n\t\tInsert_Datetime\n\t)) ~> ErrorTable"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadMktDimType_InsertUpdate_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "CSVgenericWithParameter_ds",
								"type": "DatasetReference"
							},
							"name": "ReadSource"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGeneric_ds",
								"type": "DatasetReference"
							},
							"name": "RelationalDimTypeLkp"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "TargetDim"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "ErrorTable"
						}
					],
					"transformations": [
						{
							"name": "SelectDimTypeLkp"
						},
						{
							"name": "DataTransformation"
						},
						{
							"name": "CheckDimensionRecordExist"
						},
						{
							"name": "AddAdditionalAudit"
						},
						{
							"name": "AlterRowInsertUpdate"
						},
						{
							"name": "CheckInputRecord"
						},
						{
							"name": "AddErrorDetail"
						},
						{
							"name": "RemoveBlankRow"
						},
						{
							"name": "GetNewOrModified"
						},
						{
							"name": "RemoveDuplicate"
						}
					],
					"script": "parameters{\n\tGeneratedBatchDate as string,\n\tWorkbookName as string,\n\tWorksheetName as string,\n\tMasterPipelineName as string\n}\nsource(output(\n\t\tType as string,\n\t\tBasis as string,\n\t\t{Price Point} as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> ReadSource\nsource(output(\n\t\tType as string,\n\t\tBasis as string,\n\t\tPrice_Point as string,\n\t\tInsert_DateTime as timestamp\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT DISTINCT\\n       [Type]\\n      ,[Basis]\\n      ,[Price_Point]\\n      ,[Insert_DateTime]\\nFROM [datamart].[Dim_Type]\\nWHERE Type_ID != -1',\n\tformat: 'query') ~> RelationalDimTypeLkp\nRelationalDimTypeLkp select(mapColumn(\n\t\tType_Lkp = Type,\n\t\tBasis_Lkp = Basis,\n\t\tPrice_Point_Lkp = Price_Point,\n\t\tInsert_DateTime_Lkp = Insert_DateTime\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectDimTypeLkp\nReadSource derive(Source_File = concat($WorkbookName,'-', $WorksheetName),\n\t\tBatch_ID = replace(replace(replace($GeneratedBatchDate, \"-\", \"\"),\":\",\"\"),\" \",\"\"),\n\t\tProcess_Name = $MasterPipelineName) ~> DataTransformation\nRemoveDuplicate, SelectDimTypeLkp lookup(Type == Type_Lkp\n\t&& Basis == Basis_Lkp\n\t&& {Price Point} == Price_Point_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> CheckDimensionRecordExist\nGetNewOrModified derive(InsertUpdateFlag = iif(isNull(Type_Lkp) && isNull(Basis_Lkp) && isNull(Price_Point_Lkp), \"I\", \"U\"),\n\t\tInsert_DateTime = iif(isNull(Type_Lkp) && isNull(Basis_Lkp) && isNull(Price_Point_Lkp), fromUTC(currentUTC(), 'Australia/Sydney'), Insert_DateTime_Lkp),\n\t\tUpdate_DateTime = iif(isNull(Type_Lkp) && isNull(Basis_Lkp) && isNull(Price_Point_Lkp), toTimestamp(\"\"), fromUTC(currentUTC(), 'Australia/Sydney'))) ~> AddAdditionalAudit\nAddAdditionalAudit alterRow(insertIf(equals(InsertUpdateFlag,\"I\")),\n\tupdateIf(equals(InsertUpdateFlag,\"U\"))) ~> AlterRowInsertUpdate\nDataTransformation split(not(isNull(Type)) && not(isNull(Basis)) && not(isNull({Price Point})),\n\tdisjoint: false) ~> CheckInputRecord@(Valid, Invalid)\nRemoveBlankRow derive(Error_Desc = toString(\"Type/Basis/Price_Point cannot be empty\"),\n\t\tInsert_Datetime = fromUTC(currentUTC(), 'Australia/Sydney')) ~> AddErrorDetail\nCheckInputRecord@Invalid filter(not(isNull(Type)) || not(isNull(Basis)) || not(isNull({Price Point}))) ~> RemoveBlankRow\nCheckDimensionRecordExist filter(isNull(Type_Lkp) && isNull(Basis_Lkp) && isNull(Price_Point_Lkp)) ~> GetNewOrModified\nCheckInputRecord@Valid aggregate(groupBy(Type,\n\t\tBasis,\n\t\t{Price Point},\n\t\tSource_File,\n\t\tBatch_ID,\n\t\tProcess_Name),\n\tDuplicateCount = count()) ~> RemoveDuplicate\nAlterRowInsertUpdate sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['Type','Basis','Price_Point'],\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tType,\n\t\tBasis,\n\t\tPrice_Point = {Price Point},\n\t\tSource_File,\n\t\tBatch_ID,\n\t\tProcess_Name,\n\t\tInsert_DateTime,\n\t\tUpdate_DateTime\n\t),\n\tpartitionBy('hash', 1)) ~> TargetDim\nAddErrorDetail sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tType,\n\t\tBasis,\n\t\tPrice_Point = {Price Point},\n\t\tSource_File,\n\t\tProcess_Name,\n\t\tError_Desc,\n\t\tInsert_Datetime\n\t)) ~> ErrorTable"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadMktDimUom_InsertUpdate_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "CSVgenericWithParameter_ds",
								"type": "DatasetReference"
							},
							"name": "ReadSource"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGeneric_ds",
								"type": "DatasetReference"
							},
							"name": "RelationalDimUomLkp"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "TargetDim"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "ErrorTable"
						}
					],
					"transformations": [
						{
							"name": "SelectDimUomLkp"
						},
						{
							"name": "DataTransformation"
						},
						{
							"name": "CheckDimensionRecordExist"
						},
						{
							"name": "AddAdditionalAudit"
						},
						{
							"name": "AlterRowInsertUpdate"
						},
						{
							"name": "CheckInputRecord"
						},
						{
							"name": "AddErrorDetail"
						},
						{
							"name": "RemoveBlankRow"
						},
						{
							"name": "GetNewOrModified"
						},
						{
							"name": "RemoveDuplicate"
						},
						{
							"name": "ReplaceNullToUndefined"
						}
					],
					"script": "parameters{\n\tGeneratedBatchDate as string,\n\tWorkbookName as string,\n\tWorksheetName as string,\n\tMasterPipelineName as string\n}\nsource(output(\n\t\t{UOM Name} as string,\n\t\t{UOM Desc} as string,\n\t\t{UOM Type} as string,\n\t\t{Long Description} as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> ReadSource\nsource(output(\n\t\tUOM_Name as string,\n\t\tUOM_Desc as string,\n\t\tUOM_Type as string,\n\t\tUOM_Long_Desc as string,\n\t\tInsert_DateTime as timestamp\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT DISTINCT\\n       [UOM_Name]\\n      ,[UOM_Desc]\\n      ,[UOM_Type]\\n      ,[UOM_Long_Desc]\\n      ,[Insert_DateTime]\\nFROM [datamart].[Dim_UOM]\\nWHERE UOM_ID != -1',\n\tformat: 'query') ~> RelationalDimUomLkp\nRelationalDimUomLkp select(mapColumn(\n\t\tUOM_Name_Lkp = UOM_Name,\n\t\tUOM_Desc_Lkp = UOM_Desc,\n\t\tUOM_Type_Lkp = UOM_Type,\n\t\tUOM_Long_Desc_Lkp = UOM_Long_Desc,\n\t\tInsert_DateTime_Lkp = Insert_DateTime\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectDimUomLkp\nReadSource derive(Source_File = concat($WorkbookName,'-', $WorksheetName),\n\t\tBatch_ID = replace(replace(replace($GeneratedBatchDate, \"-\", \"\"),\":\",\"\"),\" \",\"\"),\n\t\tProcess_Name = $MasterPipelineName) ~> DataTransformation\nRemoveDuplicate, SelectDimUomLkp lookup({UOM Name} == UOM_Name_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> CheckDimensionRecordExist\nGetNewOrModified derive(InsertUpdateFlag = iif(isNull(UOM_Name_Lkp), \"I\", \"U\"),\n\t\tInsert_DateTime = iif(isNull(UOM_Name_Lkp), fromUTC(currentUTC(), 'Australia/Sydney'), Insert_DateTime_Lkp),\n\t\tUpdate_DateTime = iif(isNull(UOM_Name_Lkp), toTimestamp(\"\"), fromUTC(currentUTC(), 'Australia/Sydney'))) ~> AddAdditionalAudit\nAddAdditionalAudit alterRow(insertIf(equals(InsertUpdateFlag,\"I\")),\n\tupdateIf(equals(InsertUpdateFlag,\"U\"))) ~> AlterRowInsertUpdate\nDataTransformation split(not(isNull({UOM Name})),\n\tdisjoint: false) ~> CheckInputRecord@(Valid, Invalid)\nRemoveBlankRow derive(Error_Desc = toString(\"UOM Name cannot be empty\"),\n\t\tInsert_Datetime = fromUTC(currentUTC(), 'Australia/Sydney')) ~> AddErrorDetail\nCheckInputRecord@Invalid filter(not(isNull({UOM Name})) || not(isNull({UOM Desc})) || not(isNull({UOM Type})) || not(isNull({Long Description}))) ~> RemoveBlankRow\nCheckDimensionRecordExist filter(isNull(UOM_Name_Lkp) || \r\nnotEquals({UOM Desc}, UOM_Desc_Lkp) || notEquals({UOM Type}, UOM_Type_Lkp) || notEquals({Long Description}, UOM_Long_Desc_Lkp)) ~> GetNewOrModified\nReplaceNullToUndefined aggregate(groupBy({UOM Name},\n\t\t{UOM Desc},\n\t\t{UOM Type},\n\t\t{Long Description},\n\t\tSource_File,\n\t\tBatch_ID,\n\t\tProcess_Name),\n\tDuplicateCount = count()) ~> RemoveDuplicate\nCheckInputRecord@Valid derive({UOM Desc} = iifNull({UOM Desc}, \"Undefined\"),\n\t\t{UOM Type} = iifNull({UOM Type}, \"Undefined\"),\n\t\t{Long Description} = iifNull({Long Description}, \"Undefined\")) ~> ReplaceNullToUndefined\nAlterRowInsertUpdate sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['UOM_Name'],\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tUOM_Name = {UOM Name},\n\t\tUOM_Desc = {UOM Desc},\n\t\tUOM_Type = {UOM Type},\n\t\tUOM_Long_Desc = {Long Description},\n\t\tSource_File,\n\t\tBatch_ID,\n\t\tProcess_Name,\n\t\tInsert_DateTime,\n\t\tUpdate_DateTime\n\t),\n\tpartitionBy('hash', 1)) ~> TargetDim\nAddErrorDetail sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tUOM_Name = {UOM Name},\n\t\tUOM_Desc = {UOM Desc},\n\t\tUOM_Type = {UOM Type},\n\t\tLong_Description = {Long Description},\n\t\tSource_File,\n\t\tProcess_Name,\n\t\tError_Desc,\n\t\tInsert_Datetime\n\t)) ~> ErrorTable"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadMktFactMarket_Pass1_InsertNewSpeciesProductDims_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "CSVgenericWithParameter_ds",
								"type": "DatasetReference"
							},
							"name": "ReadSource"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGeneric_ds",
								"type": "DatasetReference"
							},
							"name": "DatamartDimProductLkp"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGeneric_ds",
								"type": "DatasetReference"
							},
							"name": "DatamartDimSpeciesLkp"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "InsertNewSpeciesDim"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "InsertNewProductDim"
						}
					],
					"transformations": [
						{
							"name": "SelectDimProductLkp"
						},
						{
							"name": "DataTransformation"
						},
						{
							"name": "SelectDimSpeciesLkp"
						},
						{
							"name": "LookupDimSpecies"
						},
						{
							"name": "LookupDimProduct"
						},
						{
							"name": "FilterProcessGroup"
						},
						{
							"name": "GetUniqueSpicesProductCombination"
						},
						{
							"name": "SplitSpeciesProductDetails"
						},
						{
							"name": "SelectSpeciesOutput"
						},
						{
							"name": "SelectProductOutput"
						},
						{
							"name": "AddPoductDetails"
						},
						{
							"name": "RemoveBlankSpeciesProduct"
						},
						{
							"name": "DerivedSpeciesDetails"
						}
					],
					"script": "parameters{\n\tGeneratedBatchDate as string,\n\tWorkbookName as string,\n\tWorksheetName as string,\n\tMasterPipelineName as string,\n\tProduct_Group as string\n}\nsource(output(\n\t\t{Source Metric} as string,\n\t\t{Period Date} as string,\n\t\tCountry as string,\n\t\tRegion as string,\n\t\t{Species Common Name} as string,\n\t\t{Product Common Name} as string,\n\t\tCurrency as string,\n\t\tUOM as string,\n\t\tMarket as string,\n\t\t{Delivery Point} as string,\n\t\tIndicator as string,\n\t\tType as string,\n\t\tBasis as string,\n\t\t{Origin Port Country} as string,\n\t\t{Origin Port Region} as string,\n\t\t{Origin Port} as string,\n\t\t{Destination Port Country} as string,\n\t\t{Destination Port Region} as string,\n\t\t{Destination Port} as string,\n\t\t{Vessel Name} as string,\n\t\tLow as string,\n\t\tHigh as string,\n\t\tAverage as string,\n\t\tSpot as string,\n\t\tComment as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> ReadSource\nsource(output(\n\t\tProduct_Id as integer,\n\t\tProduct_Code as string,\n\t\tProduct_Type as string,\n\t\tProduct_Global_Grade as string,\n\t\tProduct_Common_Name as string,\n\t\tProduct_Desc as string,\n\t\tProduct_Group as string,\n\t\tGL_Code as string,\n\t\tSpecies_Common_Name as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT DISTINCT [Product_Id]\\n      ,[Product_Code]\\n      ,[Product_Type]\\n      ,[Product_Global_Grade]\\n      ,[Product_Common_Name]\\n      ,[Product_Desc]\\n      ,[Product_Group]\\n      ,[GL_Code]\\n      ,[Species_Common_Name]\\nFROM [datamart].[Dim_Product]\\nWHERE [Product_Id] != -1',\n\tformat: 'query') ~> DatamartDimProductLkp\nsource(output(\n\t\tSpecies_ID as integer,\n\t\tSpecies_Code as string,\n\t\tGenus as string,\n\t\tSpecies as string,\n\t\tSpecies_Common_Name as string,\n\t\tSpecies_Group as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT DISTINCT [Species_ID]\\n      ,[Species_Code]\\n      ,[Genus]\\n      ,[Species]\\n      ,[Species_Common_Name]\\n      ,[Species_Group]\\n  FROM [datamart].[Dim_Species]\\nWHERE [Species_ID] != -1',\n\tformat: 'query') ~> DatamartDimSpeciesLkp\nFilterProcessGroup select(mapColumn(\n\t\tProduct_Id_Lkp = Product_Id,\n\t\tProduct_Code_Lkp = Product_Code,\n\t\tProduct_Type_Lkp = Product_Type,\n\t\tProduct_Global_Grade_Lkp = Product_Global_Grade,\n\t\tProduct_Common_Name_Lkp = Product_Common_Name,\n\t\tProduct_Desc_Lkp = Product_Desc,\n\t\tProduct_Group_Lkp = Product_Group,\n\t\tGL_Code_Lkp = GL_Code,\n\t\tProduct_Species_Common_Name_Lkp = Species_Common_Name\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectDimProductLkp\nGetUniqueSpicesProductCombination derive(Source_File = concat($WorkbookName,'-', $WorksheetName),\n\t\tBatch_ID = replace(replace(replace($GeneratedBatchDate, \"-\", \"\"),\":\",\"\"),\" \",\"\"),\n\t\tProcess_Name = $MasterPipelineName,\n\t\tInsert_DateTime = fromUTC(currentUTC(), 'Australia/Sydney')) ~> DataTransformation\nDatamartDimSpeciesLkp select(mapColumn(\n\t\tSpecies_ID_Lkp = Species_ID,\n\t\tSpecies_Code_Lkp = Species_Code,\n\t\tGenus_Lkp = Genus,\n\t\tSpecies_Lkp = Species,\n\t\tSpecies_Common_Name_Lkp = Species_Common_Name,\n\t\tSpecies_Group_Lkp = Species_Group\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectDimSpeciesLkp\nDataTransformation, SelectDimSpeciesLkp lookup({Species Common Name} == Species_Common_Name_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupDimSpecies\nLookupDimSpecies, SelectDimProductLkp lookup({Product Common Name} == Product_Common_Name_Lkp\n\t&& {Species Common Name} == Product_Species_Common_Name_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupDimProduct\nDatamartDimProductLkp filter(Product_Group == $Product_Group) ~> FilterProcessGroup\nRemoveBlankSpeciesProduct aggregate(groupBy({Species Common Name},\n\t\t{Product Common Name}),\n\tUniqueCount = count()) ~> GetUniqueSpicesProductCombination\nLookupDimProduct split(isNull(Species_ID_Lkp),\n\tisNull(Product_Id_Lkp) || (not(isNull(Species_ID_Lkp)) && not(isNull(Product_Id_Lkp)) && notEquals(Species_Common_Name_Lkp, Product_Species_Common_Name_Lkp)),\n\tdisjoint: true) ~> SplitSpeciesProductDetails@(Species, Product)\nDerivedSpeciesDetails select(mapColumn(\n\t\tSpecies_Code,\n\t\tGenus,\n\t\tSpecies,\n\t\tSpecies_Common_Name = {Species Common Name},\n\t\tSpecies_Group,\n\t\tSource_File,\n\t\tBatch_ID,\n\t\tProcess_Name,\n\t\tInsert_DateTime\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectSpeciesOutput\nAddPoductDetails select(mapColumn(\n\t\tProduct_Code,\n\t\tProduct_Type,\n\t\tProduct_Global_Grade,\n\t\tProduct_Common_Name = {Product Common Name},\n\t\tProduct_Desc,\n\t\tProduct_Group,\n\t\tGL_Code,\n\t\tSpecies_Common_Name = {Species Common Name},\n\t\tSource_File,\n\t\tBatch_ID,\n\t\tProcess_Name,\n\t\tInsert_DateTime\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectProductOutput\nSplitSpeciesProductDetails@Product derive(Product_Group = $Product_Group,\n\t\tProduct_Code = 'Undefined',\n\t\tProduct_Type = 'Undefined',\n\t\tProduct_Global_Grade = 'Undefined',\n\t\tProduct_Desc = 'Undefined',\n\t\tGL_Code = 'Undefined') ~> AddPoductDetails\nReadSource filter(not(isNull({Species Common Name})) && not(isNull({Product Common Name}))) ~> RemoveBlankSpeciesProduct\nSplitSpeciesProductDetails@Species derive(Species_Code = 'Undefined',\n\t\tGenus = 'Undefined',\n\t\tSpecies = 'Undefined',\n\t\tSpecies_Group = 'Undefined') ~> DerivedSpeciesDetails\nSelectSpeciesOutput sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tSpecies_Code,\n\t\tGenus,\n\t\tSpecies,\n\t\tSpecies_Common_Name,\n\t\tSpecies_Group,\n\t\tSource_File,\n\t\tBatch_ID,\n\t\tProcess_Name,\n\t\tInsert_DateTime\n\t)) ~> InsertNewSpeciesDim\nSelectProductOutput sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tProduct_Code,\n\t\tProduct_Type,\n\t\tProduct_Global_Grade,\n\t\tProduct_Common_Name,\n\t\tProduct_Desc,\n\t\tProduct_Group,\n\t\tGL_Code,\n\t\tSpecies_Common_Name,\n\t\tSource_File,\n\t\tBatch_ID,\n\t\tProcess_Name,\n\t\tInsert_DateTime\n\t)) ~> InsertNewProductDim"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadMktFactMarket_Pass2_ProcessAndPopulate_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "CSVgenericWithParameter_ds",
								"type": "DatasetReference"
							},
							"name": "ReadSource"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGeneric_ds",
								"type": "DatasetReference"
							},
							"name": "DatamartDimProductLkp"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGeneric_ds",
								"type": "DatasetReference"
							},
							"name": "DatamartDimSpeciesLkp"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGeneric_ds",
								"type": "DatasetReference"
							},
							"name": "DatamartDimDataSource"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGeneric_ds",
								"type": "DatasetReference"
							},
							"name": "DatamartDimTypePartial"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGeneric_ds",
								"type": "DatasetReference"
							},
							"name": "DatamartDimRegion"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGeneric_ds",
								"type": "DatasetReference"
							},
							"name": "RelationalDateDimension"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGeneric_ds",
								"type": "DatasetReference"
							},
							"name": "DatamartDimUom"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGeneric_ds",
								"type": "DatasetReference"
							},
							"name": "DatamartDimDeliveryPoint"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGeneric_ds",
								"type": "DatasetReference"
							},
							"name": "DatamartDimCurrency"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGeneric_ds",
								"type": "DatasetReference"
							},
							"name": "DatamartDimIndicator"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGeneric_ds",
								"type": "DatasetReference"
							},
							"name": "DatamartDimType"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "FactErrorTable"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "TargetFactInsert"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "TargetFactDelete"
						}
					],
					"transformations": [
						{
							"name": "SelectDimProductLkp"
						},
						{
							"name": "DataTransformation"
						},
						{
							"name": "CheckInputRecord"
						},
						{
							"name": "SelectDimSpeciesLkp"
						},
						{
							"name": "LookupDimSpecies"
						},
						{
							"name": "LookupDimCurrency"
						},
						{
							"name": "SelectDimDataSourceLkp"
						},
						{
							"name": "SelectDimTypePartialLkp"
						},
						{
							"name": "SelectDimRegionLkp"
						},
						{
							"name": "SelectDateDimensionLkp"
						},
						{
							"name": "SelectDimUomLkp"
						},
						{
							"name": "SelectDimDeliverPointLkp"
						},
						{
							"name": "SelectDimCurrencyLkp"
						},
						{
							"name": "SelectDimIndicatorLkp"
						},
						{
							"name": "LookupDimProduct"
						},
						{
							"name": "LookupDimDataSource"
						},
						{
							"name": "LookupDateDimension"
						},
						{
							"name": "LookupDimUom"
						},
						{
							"name": "LookupDimDeliveryPoint"
						},
						{
							"name": "LookupDimIndicator"
						},
						{
							"name": "LookupDimRegionUseCountryRegionKeys"
						},
						{
							"name": "LookupDimRegionUseCountryKey"
						},
						{
							"name": "RenameRegionLkpAddCR"
						},
						{
							"name": "RenameRegionLkpAddCO"
						},
						{
							"name": "LookupOriginPort"
						},
						{
							"name": "RenameOriginPortLkpColumnsAddOP"
						},
						{
							"name": "LookupDestinationPort"
						},
						{
							"name": "RenameDestinationPortAddDP"
						},
						{
							"name": "LookupTypeDimensionPartial"
						},
						{
							"name": "SelectRequiredColumns"
						},
						{
							"name": "DataTransformation2"
						},
						{
							"name": "Unpivot"
						},
						{
							"name": "SelectDimTypeLkp"
						},
						{
							"name": "LookupDimType"
						},
						{
							"name": "SelectOutput"
						},
						{
							"name": "DataTransformation3"
						},
						{
							"name": "FilterInvalidRows"
						},
						{
							"name": "DerivedErrorMessage"
						},
						{
							"name": "CombinedErrMsg"
						},
						{
							"name": "SelectErrorOutput"
						},
						{
							"name": "FilterProcessGroup"
						},
						{
							"name": "RemoveInvalidType"
						},
						{
							"name": "GetFactBusinessKeys"
						},
						{
							"name": "SelectDeleteColumns"
						},
						{
							"name": "AlterRowDelete"
						}
					],
					"script": "parameters{\n\tGeneratedBatchDate as string,\n\tWorkbookName as string,\n\tWorksheetName as string,\n\tMasterPipelineName as string,\n\tProduct_Group as string,\n\tDimSchemaName as string,\n\tErrorSchemaName as string,\n\tShortFactTableName as string,\n\tShortErrorTableName as string\n}\nsource(output(\n\t\t{Source Metric} as string,\n\t\t{Period Date} as string,\n\t\tCountry as string,\n\t\tRegion as string,\n\t\t{Species Common Name} as string,\n\t\t{Product Common Name} as string,\n\t\tCurrency as string,\n\t\tUOM as string,\n\t\tMarket as string,\n\t\t{Delivery Point} as string,\n\t\tIndicator as string,\n\t\tType as string,\n\t\tBasis as string,\n\t\t{Origin Port Country} as string,\n\t\t{Origin Port Region} as string,\n\t\t{Origin Port} as string,\n\t\t{Destination Port Country} as string,\n\t\t{Destination Port Region} as string,\n\t\t{Destination Port} as string,\n\t\t{Vessel Name} as string,\n\t\tLow as string,\n\t\tHigh as string,\n\t\tAverage as string,\n\t\tSpot as string,\n\t\tComment as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false) ~> ReadSource\nsource(output(\n\t\tProduct_Id as integer,\n\t\tProduct_Code as string,\n\t\tProduct_Type as string,\n\t\tProduct_Global_Grade as string,\n\t\tProduct_Common_Name as string,\n\t\tProduct_Desc as string,\n\t\tProduct_Group as string,\n\t\tGL_Code as string,\n\t\tSpecies_Common_Name as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT DISTINCT [Product_Id]\\n      ,[Product_Code]\\n      ,[Product_Type]\\n      ,[Product_Global_Grade]\\n      ,[Product_Common_Name]\\n      ,[Product_Desc]\\n      ,[Product_Group]\\n      ,[GL_Code]\\n      ,[Species_Common_Name]\\nFROM [datamart].[Dim_Product]\\nWHERE [Product_Id] != -1',\n\tformat: 'query') ~> DatamartDimProductLkp\nsource(output(\n\t\tSpecies_ID as integer,\n\t\tSpecies_Code as string,\n\t\tGenus as string,\n\t\tSpecies as string,\n\t\tSpecies_Common_Name as string,\n\t\tSpecies_Group as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT DISTINCT [Species_ID]\\n      ,[Species_Code]\\n      ,[Genus]\\n      ,[Species]\\n      ,[Species_Common_Name]\\n      ,[Species_Group]\\n  FROM [datamart].[Dim_Species]\\nWHERE [Species_ID] != -1',\n\tformat: 'query') ~> DatamartDimSpeciesLkp\nsource(output(\n\t\tData_Source_Id as integer,\n\t\tMetric_Short_Name as string,\n\t\tSource_Name as string,\n\t\tSource_Type as string,\n\t\tSource_Link as string,\n\t\tSource_Data_Type as string,\n\t\tData_Process_Type as string,\n\t\tSource_Status as string,\n\t\tFrequency as string,\n\t\tConfidence_Level as string,\n\t\tPerson_Responsible as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT DISTINCT [Data_Source_Id]\\n      ,[Metric_Short_Name]\\n      ,[Source_Name]\\n      ,[Source_Type]\\n      ,[Source_Link]\\n      ,[Source_Data_Type]\\n      ,[Data_Process_Type]\\n      ,[Source_Status]\\n      ,[Frequency]\\n      ,[Confidence_Level]\\n      ,[Person_Responsible]\\nFROM [datamart].[Dim_Data_Source]\\nWHERE [Data_Source_Id] != -1',\n\tformat: 'query') ~> DatamartDimDataSource\nsource(output(\n\t\tType as string,\n\t\tBasis as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT DISTINCT\\n       [Type]\\n      ,[Basis]\\nFROM [datamart].[Dim_Type]\\nWHERE [Type_ID] != -1',\n\tformat: 'query') ~> DatamartDimTypePartial\nsource(output(\n\t\tRegion_ID as integer,\n\t\tCountry_Code as string,\n\t\tCountry as string,\n\t\tRegion_Code as string,\n\t\tRegion as string,\n\t\tPort_Loc as string,\n\t\tLong as decimal(20,15),\n\t\tLat as decimal(20,15)\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT DISTINCT [Region_ID]\\n      ,[Country_Code]\\n      ,[Country]\\n      ,[Region_Code]\\n      ,[Region]\\n      ,[Port_Loc]\\n      ,[Long]\\n      ,[Lat]\\nFROM [datamart].[Dim_Region]\\nWHERE [Region_ID] != -1',\n\tformat: 'query') ~> DatamartDimRegion\nsource(output(\n\t\tDate as date\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT [Date]\\nFROM [relational].[DateDimension]',\n\tformat: 'query') ~> RelationalDateDimension\nsource(output(\n\t\tUOM_ID as integer,\n\t\tUOM_Name as string,\n\t\tUOM_Desc as string,\n\t\tUOM_Type as string,\n\t\tUOM_Long_Desc as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT DISTINCT [UOM_ID]\\n      ,[UOM_Name]\\n      ,[UOM_Desc]\\n      ,[UOM_Type]\\n      ,[UOM_Long_Desc]\\nFROM [datamart].[Dim_UOM]\\nWHERE [UOM_ID] != -1',\n\tformat: 'query') ~> DatamartDimUom\nsource(output(\n\t\tDelivery_Point_ID as integer,\n\t\tDeliver_Point_Code as string,\n\t\tDelivery_Point as string,\n\t\tDelivery_Point_Desc as string,\n\t\tDelivery_Point_Long_Desc as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT DISTINCT [Delivery_Point_ID]\\n      ,[Deliver_Point_Code]\\n      ,[Delivery_Point]\\n      ,[Delivery_Point_Desc]\\n      ,[Delivery_Point_Long_Desc]\\nFROM [datamart].[Dim_Delivery_Point]\\nWHERE [Delivery_Point_ID] != -1',\n\tformat: 'query') ~> DatamartDimDeliveryPoint\nsource(output(\n\t\tCurrency_ID as integer,\n\t\tCurrency_Code as string,\n\t\tCurrency_Name as string,\n\t\tCurrency_Numeric_Code as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT DISTINCT [Currency_ID]\\n      ,[Currency_Code]\\n      ,[Currency_Name]\\n      ,[Currency_Numeric_Code]\\nFROM [datamart].[Dim_Currency]\\nWHERE [Currency_ID] != -1',\n\tformat: 'query') ~> DatamartDimCurrency\nsource(output(\n\t\tIndicator_Id as integer,\n\t\tIndicator_Code as string,\n\t\tIndicator_Desc as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT DISTINCT [Indicator_Id]\\n      ,[Indicator_Code]\\n      ,[Indicator_Desc]\\nFROM [datamart].[Dim_Indicator]\\nWHERE [Indicator_Id] != -1',\n\tformat: 'query') ~> DatamartDimIndicator\nsource(output(\n\t\tType_ID as integer,\n\t\tType as string,\n\t\tBasis as string,\n\t\tPrice_Point as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT DISTINCT [Type_ID]\\n      ,[Type]\\n      ,[Basis]\\n      ,[Price_Point]\\nFROM [datamart].[Dim_Type]\\nWHERE [Type_ID] != -1',\n\tformat: 'query') ~> DatamartDimType\nFilterProcessGroup select(mapColumn(\n\t\tProduct_Id_Lkp = Product_Id,\n\t\tProduct_Code_Lkp = Product_Code,\n\t\tProduct_Type_Lkp = Product_Type,\n\t\tProduct_Global_Grade_Lkp = Product_Global_Grade,\n\t\tProduct_Common_Name_Lkp = Product_Common_Name,\n\t\tProduct_Desc_Lkp = Product_Desc,\n\t\tProduct_Group_Lkp = Product_Group,\n\t\tGL_Code_Lkp = GL_Code,\n\t\tProduct_Species_Common_Name_Lkp = Species_Common_Name\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectDimProductLkp\nReadSource derive(Source_File = concat($WorkbookName,'-', $WorksheetName),\n\t\tBatch_ID = replace(replace(replace($GeneratedBatchDate, \"-\", \"\"),\":\",\"\"),\" \",\"\"),\n\t\tProcess_Name = $MasterPipelineName,\n\t\t{Period Date} = toDate({Period Date}),\n\t\tCountry_Redefined_For_Lkp = iifNull(Country, \"Undefined\"),\n\t\tRegion_Redefined_For_Lkp = iifNull(Region, \"Undefined\"),\n\t\tInsert_Datetime = fromUTC(currentUTC(), 'Australia/Sydney')) ~> DataTransformation\nRenameDestinationPortAddDP split(not(isNull(DateDimension_Date_Lkp)) && \r\nnot(isNull(Data_Source_Id_Lkp)) && \r\n( not(isNull(Species_ID_Lkp)) && not(isNull(Product_Id_Lkp)) && equals({Species Common Name}, Product_Species_Common_Name_Lkp) ) && \r\n( not(isNull(Region_ID_Lkp_CR)) || ( isNull(Region) && not(isNull(Region_ID_Lkp_CO)) ) ) && \r\n( not(isNull(Type_Lkp)) && not(isNull(Basis_Lkp)) ) && \r\n\r\n\r\n( isNull(Currency) || not(isNull(Currency_ID_Lkp)) ) && \r\n( isNull(UOM) || not(isNull(UOM_ID_Lkp)) ) && \r\n( isNull({Delivery Point}) || not(isNull(Delivery_Point_ID_Lkp)) ) &&\r\n( isNull(Indicator) || not(isNull(Indicator_Id_Lkp))) &&\r\n( (isNull({Origin Port Country}) && isNull({Origin Port Region}) && isNull({Origin Port})) || not(isNull(Region_ID_Lkp_OP)) ) &&\r\n( (isNull({Destination Port Country}) && isNull({Destination Port Region}) && isNull({Destination Port})) || not(isNull(Region_ID_Lkp_DP)) ),\n\tdisjoint: false) ~> CheckInputRecord@(Valid, Invalid)\nDatamartDimSpeciesLkp select(mapColumn(\n\t\tSpecies_ID_Lkp = Species_ID,\n\t\tSpecies_Code_Lkp = Species_Code,\n\t\tGenus_Lkp = Genus,\n\t\tSpecies_Lkp = Species,\n\t\tSpecies_Common_Name_Lkp = Species_Common_Name,\n\t\tSpecies_Group_Lkp = Species_Group\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectDimSpeciesLkp\nDataTransformation, SelectDimSpeciesLkp lookup({Species Common Name} == Species_Common_Name_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupDimSpecies\nLookupTypeDimensionPartial, SelectDimCurrencyLkp lookup(Currency == Currency_Code_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupDimCurrency\nDatamartDimDataSource select(mapColumn(\n\t\tData_Source_Id_Lkp = Data_Source_Id,\n\t\tMetric_Short_Name_Lkp = Metric_Short_Name,\n\t\tSource_Name_Lkp = Source_Name,\n\t\tSource_Type_Lkp = Source_Type,\n\t\tSource_Link_Lkp = Source_Link,\n\t\tSource_Data_Type_Lkp = Source_Data_Type,\n\t\tData_Process_Type_Lkp = Data_Process_Type,\n\t\tSource_Status_Lkp = Source_Status,\n\t\tFrequency_Lkp = Frequency,\n\t\tConfidence_Level_Lkp = Confidence_Level,\n\t\tPerson_Responsible_Lkp = Person_Responsible\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectDimDataSourceLkp\nDatamartDimTypePartial select(mapColumn(\n\t\tType_Lkp = Type,\n\t\tBasis_Lkp = Basis\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectDimTypePartialLkp\nDatamartDimRegion select(mapColumn(\n\t\tRegion_ID_Lkp = Region_ID,\n\t\tCountry_Code_Lkp = Country_Code,\n\t\tCountry_Lkp = Country,\n\t\tRegion_Code_Lkp = Region_Code,\n\t\tRegion_Lkp = Region,\n\t\tPort_Loc_Lkp = Port_Loc,\n\t\tLong_Lkp = Long,\n\t\tLat_Lkp = Lat\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectDimRegionLkp\nRelationalDateDimension select(mapColumn(\n\t\tDateDimension_Date_Lkp = Date\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectDateDimensionLkp\nDatamartDimUom select(mapColumn(\n\t\tUOM_ID_Lkp = UOM_ID,\n\t\tUOM_Name_Lkp = UOM_Name,\n\t\tUOM_Desc_Lkp = UOM_Desc,\n\t\tUOM_Type_Lkp = UOM_Type,\n\t\tUOM_Long_Desc_Lkp = UOM_Long_Desc\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectDimUomLkp\nDatamartDimDeliveryPoint select(mapColumn(\n\t\tDelivery_Point_ID_Lkp = Delivery_Point_ID,\n\t\tDeliver_Point_Code_Lkp = Deliver_Point_Code,\n\t\tDelivery_Point_Lkp = Delivery_Point,\n\t\tDelivery_Point_Desc_Lkp = Delivery_Point_Desc,\n\t\tDelivery_Point_Long_Desc_Lkp = Delivery_Point_Long_Desc\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectDimDeliverPointLkp\nDatamartDimCurrency select(mapColumn(\n\t\tCurrency_ID_Lkp = Currency_ID,\n\t\tCurrency_Code_Lkp = Currency_Code,\n\t\tCurrency_Name_Lkp = Currency_Name,\n\t\tCurrency_Numeric_Code_Lkp = Currency_Numeric_Code\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectDimCurrencyLkp\nDatamartDimIndicator select(mapColumn(\n\t\tIndicator_Id_Lkp = Indicator_Id,\n\t\tIndicator_Code_Lkp = Indicator_Code,\n\t\tIndicator_Desc_Lkp = Indicator_Desc\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectDimIndicatorLkp\nLookupDimSpecies, SelectDimProductLkp lookup({Product Common Name} == Product_Common_Name_Lkp\n\t&& {Species Common Name} == Product_Species_Common_Name_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupDimProduct\nRenameRegionLkpAddCO, SelectDimDataSourceLkp lookup({Source Metric} == Metric_Short_Name_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupDimDataSource\nLookupDimDataSource, SelectDateDimensionLkp lookup({Period Date} == DateDimension_Date_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupDateDimension\nLookupDimCurrency, SelectDimUomLkp lookup(UOM == UOM_Name_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupDimUom\nLookupDimUom, SelectDimDeliverPointLkp lookup({Delivery Point} == Delivery_Point_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupDimDeliveryPoint\nLookupDimDeliveryPoint, SelectDimIndicatorLkp lookup(Indicator == Indicator_Desc_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupDimIndicator\nLookupDimProduct, SelectDimRegionLkp lookup(Country_Redefined_For_Lkp == Country_Lkp\n\t&& Region_Redefined_For_Lkp == Region_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupDimRegionUseCountryRegionKeys\nRenameRegionLkpAddCR, SelectDimRegionLkp lookup(Country_Redefined_For_Lkp == Country_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupDimRegionUseCountryKey\nLookupDimRegionUseCountryRegionKeys select(mapColumn(\n\t\t{Source Metric},\n\t\t{Period Date},\n\t\tCountry,\n\t\tRegion,\n\t\t{Species Common Name},\n\t\t{Product Common Name},\n\t\tCurrency,\n\t\tUOM,\n\t\tMarket,\n\t\t{Delivery Point},\n\t\tIndicator,\n\t\tType,\n\t\tBasis,\n\t\t{Origin Port Country},\n\t\t{Origin Port Region},\n\t\t{Origin Port},\n\t\t{Destination Port Country},\n\t\t{Destination Port Region},\n\t\t{Destination Port},\n\t\t{Vessel Name},\n\t\tLow,\n\t\tHigh,\n\t\tAverage,\n\t\tSpot,\n\t\tComment,\n\t\tSource_File,\n\t\tBatch_ID,\n\t\tProcess_Name,\n\t\tInsert_Datetime,\n\t\tCountry_Redefined_For_Lkp,\n\t\tRegion_Redefined_For_Lkp,\n\t\tSpecies_ID_Lkp,\n\t\tSpecies_Code_Lkp,\n\t\tGenus_Lkp,\n\t\tSpecies_Lkp,\n\t\tSpecies_Common_Name_Lkp,\n\t\tSpecies_Group_Lkp,\n\t\tProduct_Id_Lkp,\n\t\tProduct_Code_Lkp,\n\t\tProduct_Type_Lkp,\n\t\tProduct_Global_Grade_Lkp,\n\t\tProduct_Common_Name_Lkp,\n\t\tProduct_Desc_Lkp,\n\t\tProduct_Group_Lkp,\n\t\tGL_Code_Lkp,\n\t\tProduct_Species_Common_Name_Lkp,\n\t\tRegion_ID_Lkp_CR = Region_ID_Lkp,\n\t\tCountry_Code_Lkp_CR = Country_Code_Lkp,\n\t\tCountry_Lkp_CR = Country_Lkp,\n\t\tRegion_Code_Lkp_CR = Region_Code_Lkp,\n\t\tRegion_Lkp_CR = Region_Lkp,\n\t\tPort_Loc_Lkp_CR = Port_Loc_Lkp,\n\t\tLong_Lkp_CR = Long_Lkp,\n\t\tLat_Lkp_CR = Lat_Lkp\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> RenameRegionLkpAddCR\nLookupDimRegionUseCountryKey select(mapColumn(\n\t\t{Source Metric},\n\t\t{Period Date},\n\t\tCountry,\n\t\tRegion,\n\t\t{Species Common Name},\n\t\t{Product Common Name},\n\t\tCurrency,\n\t\tUOM,\n\t\tMarket,\n\t\t{Delivery Point},\n\t\tIndicator,\n\t\tType,\n\t\tBasis,\n\t\t{Origin Port Country},\n\t\t{Origin Port Region},\n\t\t{Origin Port},\n\t\t{Destination Port Country},\n\t\t{Destination Port Region},\n\t\t{Destination Port},\n\t\t{Vessel Name},\n\t\tLow,\n\t\tHigh,\n\t\tAverage,\n\t\tSpot,\n\t\tComment,\n\t\tSource_File,\n\t\tBatch_ID,\n\t\tProcess_Name,\n\t\tInsert_Datetime,\n\t\tCountry_Redefined_For_Lkp,\n\t\tRegion_Redefined_For_Lkp,\n\t\tSpecies_ID_Lkp,\n\t\tSpecies_Code_Lkp,\n\t\tGenus_Lkp,\n\t\tSpecies_Lkp,\n\t\tSpecies_Common_Name_Lkp,\n\t\tSpecies_Group_Lkp,\n\t\tProduct_Id_Lkp,\n\t\tProduct_Code_Lkp,\n\t\tProduct_Type_Lkp,\n\t\tProduct_Global_Grade_Lkp,\n\t\tProduct_Common_Name_Lkp,\n\t\tProduct_Desc_Lkp,\n\t\tProduct_Group_Lkp,\n\t\tGL_Code_Lkp,\n\t\tProduct_Species_Common_Name_Lkp,\n\t\tRegion_ID_Lkp_CR,\n\t\tCountry_Code_Lkp_CR,\n\t\tCountry_Lkp_CR,\n\t\tRegion_Code_Lkp_CR,\n\t\tRegion_Lkp_CR,\n\t\tPort_Loc_Lkp_CR,\n\t\tLong_Lkp_CR,\n\t\tLat_Lkp_CR,\n\t\tRegion_ID_Lkp_CO = Region_ID_Lkp,\n\t\tCountry_Code_Lkp_CO = Country_Code_Lkp,\n\t\tCountry_Lkp_CO = Country_Lkp,\n\t\tRegion_Code_Lkp_CO = Region_Code_Lkp,\n\t\tRegion_Lkp_CO = Region_Lkp,\n\t\tPort_Loc_Lkp_CO = Port_Loc_Lkp,\n\t\tLong_Lkp_CO = Long_Lkp,\n\t\tLat_Lkp_CO = Lat_Lkp\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> RenameRegionLkpAddCO\nLookupDimIndicator, SelectDimRegionLkp lookup({Origin Port Country} == Country_Code_Lkp\n\t&& {Destination Port Region} == Region_Code_Lkp\n\t&& {Origin Port} == Port_Loc_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupOriginPort\nLookupOriginPort select(mapColumn(\n\t\t{Source Metric},\n\t\t{Period Date},\n\t\tCountry,\n\t\tRegion,\n\t\t{Species Common Name},\n\t\t{Product Common Name},\n\t\tCurrency,\n\t\tUOM,\n\t\tMarket,\n\t\t{Delivery Point},\n\t\tIndicator,\n\t\tType,\n\t\tBasis,\n\t\t{Origin Port Country},\n\t\t{Origin Port Region},\n\t\t{Origin Port},\n\t\t{Destination Port Country},\n\t\t{Destination Port Region},\n\t\t{Destination Port},\n\t\t{Vessel Name},\n\t\tLow,\n\t\tHigh,\n\t\tAverage,\n\t\tSpot,\n\t\tComment,\n\t\tSource_File,\n\t\tBatch_ID,\n\t\tProcess_Name,\n\t\tInsert_Datetime,\n\t\tCountry_Redefined_For_Lkp,\n\t\tRegion_Redefined_For_Lkp,\n\t\tSpecies_ID_Lkp,\n\t\tSpecies_Code_Lkp,\n\t\tGenus_Lkp,\n\t\tSpecies_Lkp,\n\t\tSpecies_Common_Name_Lkp,\n\t\tSpecies_Group_Lkp,\n\t\tProduct_Id_Lkp,\n\t\tProduct_Code_Lkp,\n\t\tProduct_Type_Lkp,\n\t\tProduct_Global_Grade_Lkp,\n\t\tProduct_Common_Name_Lkp,\n\t\tProduct_Desc_Lkp,\n\t\tProduct_Group_Lkp,\n\t\tGL_Code_Lkp,\n\t\tProduct_Species_Common_Name_Lkp,\n\t\tRegion_ID_Lkp_CR,\n\t\tCountry_Code_Lkp_CR,\n\t\tCountry_Lkp_CR,\n\t\tRegion_Code_Lkp_CR,\n\t\tRegion_Lkp_CR,\n\t\tPort_Loc_Lkp_CR,\n\t\tLong_Lkp_CR,\n\t\tLat_Lkp_CR,\n\t\tRegion_ID_Lkp_CO,\n\t\tCountry_Code_Lkp_CO,\n\t\tCountry_Lkp_CO,\n\t\tRegion_Code_Lkp_CO,\n\t\tRegion_Lkp_CO,\n\t\tPort_Loc_Lkp_CO,\n\t\tLong_Lkp_CO,\n\t\tLat_Lkp_CO,\n\t\tData_Source_Id_Lkp,\n\t\tMetric_Short_Name_Lkp,\n\t\tSource_Name_Lkp,\n\t\tSource_Type_Lkp,\n\t\tSource_Link_Lkp,\n\t\tSource_Data_Type_Lkp,\n\t\tData_Process_Type_Lkp,\n\t\tSource_Status_Lkp,\n\t\tFrequency_Lkp,\n\t\tConfidence_Level_Lkp,\n\t\tPerson_Responsible_Lkp,\n\t\tDateDimension_Date_Lkp,\n\t\tType_Lkp,\n\t\tBasis_Lkp,\n\t\tCurrency_ID_Lkp,\n\t\tCurrency_Code_Lkp,\n\t\tCurrency_Name_Lkp,\n\t\tCurrency_Numeric_Code_Lkp,\n\t\tUOM_ID_Lkp,\n\t\tUOM_Name_Lkp,\n\t\tUOM_Desc_Lkp,\n\t\tUOM_Type_Lkp,\n\t\tUOM_Long_Desc_Lkp,\n\t\tDelivery_Point_ID_Lkp,\n\t\tDeliver_Point_Code_Lkp,\n\t\tDelivery_Point_Lkp,\n\t\tDelivery_Point_Desc_Lkp,\n\t\tDelivery_Point_Long_Desc_Lkp,\n\t\tIndicator_Id_Lkp,\n\t\tIndicator_Code_Lkp,\n\t\tIndicator_Desc_Lkp,\n\t\tRegion_ID_Lkp_OP = Region_ID_Lkp,\n\t\tCountry_Code_Lkp_OP = Country_Code_Lkp,\n\t\tCountry_Lkp_OP = Country_Lkp,\n\t\tRegion_Code_Lkp_OP = Region_Code_Lkp,\n\t\tRegion_Lkp_OP = Region_Lkp,\n\t\tPort_Loc_Lkp_OP = Port_Loc_Lkp,\n\t\tLong_Lkp_OP = Long_Lkp,\n\t\tLat_Lkp_OP = Lat_Lkp\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> RenameOriginPortLkpColumnsAddOP\nRenameOriginPortLkpColumnsAddOP, SelectDimRegionLkp lookup({Destination Port Country} == Country_Code_Lkp\n\t&& {Destination Port Region} == Region_Code_Lkp\n\t&& {Destination Port} == Port_Loc_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupDestinationPort\nLookupDestinationPort select(mapColumn(\n\t\t{Source Metric},\n\t\t{Period Date},\n\t\tCountry,\n\t\tRegion,\n\t\t{Species Common Name},\n\t\t{Product Common Name},\n\t\tCurrency,\n\t\tUOM,\n\t\tMarket,\n\t\t{Delivery Point},\n\t\tIndicator,\n\t\tType,\n\t\tBasis,\n\t\t{Origin Port Country},\n\t\t{Origin Port Region},\n\t\t{Origin Port},\n\t\t{Destination Port Country},\n\t\t{Destination Port Region},\n\t\t{Destination Port},\n\t\t{Vessel Name},\n\t\tLow,\n\t\tHigh,\n\t\tAverage,\n\t\tSpot,\n\t\tComment,\n\t\tSource_File,\n\t\tBatch_ID,\n\t\tProcess_Name,\n\t\tInsert_Datetime,\n\t\tCountry_Redefined_For_Lkp,\n\t\tRegion_Redefined_For_Lkp,\n\t\tSpecies_ID_Lkp,\n\t\tSpecies_Code_Lkp,\n\t\tGenus_Lkp,\n\t\tSpecies_Lkp,\n\t\tSpecies_Common_Name_Lkp,\n\t\tSpecies_Group_Lkp,\n\t\tProduct_Id_Lkp,\n\t\tProduct_Code_Lkp,\n\t\tProduct_Type_Lkp,\n\t\tProduct_Global_Grade_Lkp,\n\t\tProduct_Common_Name_Lkp,\n\t\tProduct_Desc_Lkp,\n\t\tProduct_Group_Lkp,\n\t\tGL_Code_Lkp,\n\t\tProduct_Species_Common_Name_Lkp,\n\t\tRegion_ID_Lkp_CR,\n\t\tCountry_Code_Lkp_CR,\n\t\tCountry_Lkp_CR,\n\t\tRegion_Code_Lkp_CR,\n\t\tRegion_Lkp_CR,\n\t\tPort_Loc_Lkp_CR,\n\t\tLong_Lkp_CR,\n\t\tLat_Lkp_CR,\n\t\tRegion_ID_Lkp_CO,\n\t\tCountry_Code_Lkp_CO,\n\t\tCountry_Lkp_CO,\n\t\tRegion_Code_Lkp_CO,\n\t\tRegion_Lkp_CO,\n\t\tPort_Loc_Lkp_CO,\n\t\tLong_Lkp_CO,\n\t\tLat_Lkp_CO,\n\t\tData_Source_Id_Lkp,\n\t\tMetric_Short_Name_Lkp,\n\t\tSource_Name_Lkp,\n\t\tSource_Type_Lkp,\n\t\tSource_Link_Lkp,\n\t\tSource_Data_Type_Lkp,\n\t\tData_Process_Type_Lkp,\n\t\tSource_Status_Lkp,\n\t\tFrequency_Lkp,\n\t\tConfidence_Level_Lkp,\n\t\tPerson_Responsible_Lkp,\n\t\tDateDimension_Date_Lkp,\n\t\tType_Lkp,\n\t\tBasis_Lkp,\n\t\tCurrency_ID_Lkp,\n\t\tCurrency_Code_Lkp,\n\t\tCurrency_Name_Lkp,\n\t\tCurrency_Numeric_Code_Lkp,\n\t\tUOM_ID_Lkp,\n\t\tUOM_Name_Lkp,\n\t\tUOM_Desc_Lkp,\n\t\tUOM_Type_Lkp,\n\t\tUOM_Long_Desc_Lkp,\n\t\tDelivery_Point_ID_Lkp,\n\t\tDeliver_Point_Code_Lkp,\n\t\tDelivery_Point_Lkp,\n\t\tDelivery_Point_Desc_Lkp,\n\t\tDelivery_Point_Long_Desc_Lkp,\n\t\tIndicator_Id_Lkp,\n\t\tIndicator_Code_Lkp,\n\t\tIndicator_Desc_Lkp,\n\t\tRegion_ID_Lkp_OP,\n\t\tCountry_Code_Lkp_OP,\n\t\tCountry_Lkp_OP,\n\t\tRegion_Code_Lkp_OP,\n\t\tRegion_Lkp_OP,\n\t\tPort_Loc_Lkp_OP,\n\t\tLong_Lkp_OP,\n\t\tLat_Lkp_OP,\n\t\tRegion_ID_Lkp_DP = Region_ID_Lkp,\n\t\tCountry_Code_Lkp_DP = Country_Code_Lkp,\n\t\tCountry_Lkp_DP = Country_Lkp,\n\t\tRegion_Code_Lkp_DP = Region_Code_Lkp,\n\t\tRegion_Lkp_DP = Region_Lkp,\n\t\tPort_Loc_Lkp_DP = Port_Loc_Lkp,\n\t\tLong_Lkp_DP = Long_Lkp,\n\t\tLat_Lkp_DP = Lat_Lkp\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> RenameDestinationPortAddDP\nLookupDateDimension, SelectDimTypePartialLkp lookup(Type == Type_Lkp\n\t&& Basis == Basis_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupTypeDimensionPartial\nDataTransformation2 select(mapColumn(\n\t\tDateDimension_Date_Lkp,\n\t\tData_Source_Id_Lkp,\n\t\tRegion_ID_Lkp,\n\t\tSpecies_ID_Lkp,\n\t\tProduct_Id_Lkp,\n\t\tType,\n\t\tBasis,\n\t\tLow,\n\t\tHigh,\n\t\tAverage,\n\t\tSpot,\n\t\tUOM_ID_Lkp,\n\t\tDelivery_Point_ID_Lkp,\n\t\tCurrency_ID_Lkp,\n\t\tIndicator_Id_Lkp,\n\t\tRegion_ID_Lkp_OP,\n\t\tRegion_ID_Lkp_DP,\n\t\tMarket,\n\t\t{Vessel Name},\n\t\tComment,\n\t\tBatch_ID,\n\t\tProcess_Name,\n\t\tSource_File,\n\t\tInsert_Datetime\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectRequiredColumns\nCheckInputRecord@Valid derive(Region_ID_Lkp = iifNull(Region_ID_Lkp_CR, Region_ID_Lkp_CO),\n\t\tBatch_ID = toString(Batch_ID)) ~> DataTransformation2\nSelectRequiredColumns unpivot(output(\n\t\tValue_Type as string,\n\t\tValue as string\n\t),\n\tungroupBy(DateDimension_Date_Lkp,\n\t\tData_Source_Id_Lkp,\n\t\tRegion_ID_Lkp,\n\t\tSpecies_ID_Lkp,\n\t\tProduct_Id_Lkp,\n\t\tType,\n\t\tBasis,\n\t\tUOM_ID_Lkp,\n\t\tDelivery_Point_ID_Lkp,\n\t\tCurrency_ID_Lkp,\n\t\tIndicator_Id_Lkp,\n\t\tRegion_ID_Lkp_OP,\n\t\tRegion_ID_Lkp_DP,\n\t\tMarket,\n\t\t{Vessel Name},\n\t\tComment,\n\t\tBatch_ID,\n\t\tSource_File,\n\t\tProcess_Name,\n\t\tInsert_Datetime),\n\tlateral: false,\n\tignoreNullPivots: false) ~> Unpivot\nDatamartDimType select(mapColumn(\n\t\tType_ID_Lkp = Type_ID,\n\t\tType_Lkp = Type,\n\t\tBasis_Lkp = Basis,\n\t\tPrice_Point_Lkp = Price_Point\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectDimTypeLkp\nUnpivot, SelectDimTypeLkp lookup(Type == Type_Lkp\n\t&& Basis == Basis_Lkp\n\t&& Value_Type == Price_Point_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupDimType\nDataTransformation3 select(mapColumn(\n\t\tPeriod_Date = DateDimension_Date_Lkp,\n\t\tData_Source_Id = Data_Source_Id_Lkp,\n\t\tRegion_ID = Region_ID_Lkp,\n\t\tSpecies_ID = Species_ID_Lkp,\n\t\tProduct_Id = Product_Id_Lkp,\n\t\tType_ID = Type_ID_Lkp,\n\t\tUOM_ID = UOM_ID_Lkp,\n\t\tDelivery_Point_ID = Delivery_Point_ID_Lkp,\n\t\tCurrency_ID = Currency_ID_Lkp,\n\t\tIndicator_Id = Indicator_Id_Lkp,\n\t\tOrigin_Port_ID = Region_ID_Lkp_OP,\n\t\tDestination_Port_ID = Region_ID_Lkp_DP,\n\t\tMarket,\n\t\tVessel_Name = {Vessel Name},\n\t\tValue,\n\t\tComment,\n\t\tInsert_Datetime,\n\t\tBatch_ID,\n\t\tSource_File,\n\t\tProcess_Name\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectOutput\nRemoveInvalidType derive(Value = toDecimal(iifNull(Value, '0'),20,4),\n\t\tData_Source_Id_Lkp = iifNull(Data_Source_Id_Lkp, -1),\n\t\tRegion_ID_Lkp = iifNull(Region_ID_Lkp, -1),\n\t\tSpecies_ID_Lkp = iifNull(Species_ID_Lkp, -1),\n\t\tProduct_Id_Lkp = iifNull(Product_Id_Lkp, -1),\n\t\tType_ID_Lkp = iifNull(Type_ID_Lkp, -1),\n\t\tUOM_ID_Lkp = iifNull(UOM_ID_Lkp, -1),\n\t\tDelivery_Point_ID_Lkp = iifNull(Delivery_Point_ID_Lkp, -1),\n\t\tCurrency_ID_Lkp = iifNull(Currency_ID_Lkp, -1),\n\t\tIndicator_Id_Lkp = iifNull(Indicator_Id_Lkp, -1),\n\t\tRegion_ID_Lkp_OP = iifNull(Region_ID_Lkp_OP, -1),\n\t\tRegion_ID_Lkp_DP = iifNull(Region_ID_Lkp_DP, -1)) ~> DataTransformation3\nCheckInputRecord@Invalid filter(not(isNull({Period Date})) || \r\nnot(isNull({Source Metric})) || \r\nnot(isNull({Species Common Name})) || \r\nnot(isNull({Product Common Name})) || \r\n( not(isNull(Country)) && not(isNull(Region)) ) ||\r\n( not(isNull(Country)) && isNull(Region) ) ||  \r\n( not(isNull(Type)) && not(isNull(Basis)) )) ~> FilterInvalidRows\nFilterInvalidRows derive(Period_Date_ErrMsg = iif(isNull(DateDimension_Date_Lkp), \"Period Date Error/\", \"\"),\n\t\tSource_ErrMsg = iif(isNull(Data_Source_Id_Lkp), \"Source Error/\", \"\"),\n\t\tRegion_ErrMsg = iif(isNull(iifNull(Region_ID_Lkp_CR, Region_ID_Lkp_CO)), \"Region Error/\", \"\"),\n\t\tType_ErrMsg = iif(isNull(Type_Lkp) || isNull(Basis_Lkp), \"Type Error/\", \"\"),\n\t\tSpecies_ErrMsg = iif(isNull(Species_ID_Lkp), \"Species Error/\", \"\"),\n\t\tProduct_ErrMsg = iif(isNull(Product_Id_Lkp), \"Product Error/\", \"\"),\n\t\tCurrency_ErrMsg = iif(not(isNull(Currency)) && isNull(Currency_ID_Lkp), \"Currency Error/\", \"\"),\n\t\tUom_ErrMsg = iif(not(isNull(UOM)) && isNull(UOM_ID_Lkp), \"UOM Error/\", \"\"),\n\t\tDeliveryPoint_ErrMsg = iif(not(isNull({Delivery Point})) && isNull(Delivery_Point_ID_Lkp), \"Delivery Point Error/\", \"\"),\n\t\tIndicator_ErrMsg = iif(not(isNull(Indicator)) && isNull(Indicator_Id_Lkp), \"Indicator Error/\", \"\"),\n\t\tOriginPort_ErrMsg = iif(not(isNull({Origin Port Country})) || not(isNull({Destination Port Region})) || not(isNull({Origin Port})) && isNull(Region_ID_Lkp_OP), \"Origin Port Error/\", \"\"),\n\t\tDestinationPort_ErrMsg = iif(not(isNull({Destination Port Country})) || not(isNull({Destination Port Region})) || not(isNull({Destination Port})) && isNull(Region_ID_Lkp_DP), \"Destination Port Error/\", \"\"),\n\t\tSpecies_Product_Combo_ErrMsg = iif(not(isNull(Product_Id_Lkp)) && not(isNull(Species_ID_Lkp)) && notEquals({Species Common Name},Product_Species_Common_Name_Lkp), \"Species Product Combination Error/\", \"\")) ~> DerivedErrorMessage\nDerivedErrorMessage derive(Combined_ErrMsg = concat(Period_Date_ErrMsg, Source_ErrMsg, Region_ErrMsg, Type_ErrMsg, Species_ErrMsg, Product_ErrMsg, Currency_ErrMsg, Uom_ErrMsg, DeliveryPoint_ErrMsg, Indicator_ErrMsg, OriginPort_ErrMsg, DestinationPort_ErrMsg, Species_Product_Combo_ErrMsg)) ~> CombinedErrMsg\nCombinedErrMsg select(mapColumn(\n\t\tMetric_Short_Name = {Source Metric},\n\t\tPeriod_Date = {Period Date},\n\t\tCountry,\n\t\tRegion,\n\t\tSpecies_Common_Name = {Species Common Name},\n\t\tProduct_Common_Name = {Product Common Name},\n\t\tCurrency,\n\t\tUOM,\n\t\tMarket,\n\t\tDelivery_Point = {Delivery Point},\n\t\tIndicator,\n\t\tType,\n\t\tBasis,\n\t\tOrigin_Port_Country = {Origin Port Country},\n\t\tOrigin_Port_Region = {Origin Port Region},\n\t\tOrigin_Port = {Origin Port},\n\t\tDestination_Port_Country = {Destination Port Country},\n\t\tDestination_Port_Region = {Destination Port Region},\n\t\tDestination_Port = {Destination Port},\n\t\tVessel_Name = {Vessel Name},\n\t\tLow,\n\t\tHigh,\n\t\tAverage,\n\t\tSpot,\n\t\tComment,\n\t\tInsert_Datetime,\n\t\tSource_File,\n\t\tBatch_ID,\n\t\tProcess_Name,\n\t\tError_Desc = Combined_ErrMsg\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectErrorOutput\nDatamartDimProductLkp filter(Product_Group == $Product_Group) ~> FilterProcessGroup\nLookupDimType filter(not(isNull(Type_ID_Lkp))) ~> RemoveInvalidType\nSelectOutput aggregate(groupBy(Period_Date,\n\t\tData_Source_Id,\n\t\tRegion_ID,\n\t\tSpecies_ID,\n\t\tProduct_Id,\n\t\tType_ID),\n\tUniqueCount = count()) ~> GetFactBusinessKeys\nGetFactBusinessKeys select(mapColumn(\n\t\tPeriod_Date,\n\t\tData_Source_Id,\n\t\tRegion_ID,\n\t\tSpecies_ID,\n\t\tProduct_Id,\n\t\tType_ID\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectDeleteColumns\nSelectDeleteColumns alterRow(deleteIf(not(isNull(Period_Date)))) ~> AlterRowDelete\nSelectErrorOutput sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tsaveOrder: (1),\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tMetric_Short_Name,\n\t\tPeriod_Date,\n\t\tCountry,\n\t\tRegion,\n\t\tSpecies_Common_Name,\n\t\tProduct_Common_Name,\n\t\tCurrency,\n\t\tUOM,\n\t\tMarket,\n\t\tDelivery_Point,\n\t\tIndicator,\n\t\tType,\n\t\tBasis,\n\t\tOrigin_Port_Country,\n\t\tOrigin_Port_Region,\n\t\tOrigin_Port,\n\t\tDestination_Port_Country,\n\t\tDestination_Port_Region,\n\t\tDestination_Port,\n\t\tVessel_Name,\n\t\tLow,\n\t\tHigh,\n\t\tAverage,\n\t\tSpot,\n\t\tComment,\n\t\tInsert_Datetime,\n\t\tSource_File,\n\t\tProcess_Name,\n\t\tError_Desc\n\t),\n\tpartitionBy('hash', 1)) ~> FactErrorTable\nSelectOutput sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tsaveOrder: (3),\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tPeriod_Date,\n\t\tData_Source_ID = Data_Source_Id,\n\t\tRegion_ID,\n\t\tSpecies_ID,\n\t\tProduct_ID = Product_Id,\n\t\tType_ID,\n\t\tUOM_ID,\n\t\tDelivery_Point_ID,\n\t\tCurrency_ID,\n\t\tIndicator_ID = Indicator_Id,\n\t\tOrigin_Port_ID,\n\t\tDestination_Port_Id = Destination_Port_ID,\n\t\tMarket,\n\t\tVessel_Name,\n\t\tvalue = Value,\n\t\tcomment = Comment,\n\t\tInsert_DateTime = Insert_Datetime,\n\t\tBatch_ID,\n\t\tSource_File,\n\t\tProcess_Name\n\t)) ~> TargetFactInsert\nAlterRowDelete sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:true,\n\tinsertable:false,\n\tupdateable:false,\n\tupsertable:false,\n\tkeys:['Period_Date','Data_Source_ID','Region_ID','Species_ID','Product_ID','Type_ID'],\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tsaveOrder: (2),\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tPeriod_Date,\n\t\tData_Source_ID = Data_Source_Id,\n\t\tRegion_ID,\n\t\tSpecies_ID,\n\t\tProduct_ID = Product_Id,\n\t\tType_ID\n\t)) ~> TargetFactDelete"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadStagingDBtoRelationDB_adj_n_act_trackBeginBal_dfx')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "NOTE:This DF only cater for INSERT. There is no Update to Expire for consideration The branch containing \"UpdateSelectForExpire\" kept for reference only",
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "SQLstagingadjustment_ds",
								"type": "DatasetReference"
							},
							"name": "StagingDB"
						},
						{
							"dataset": {
								"referenceName": "SQLrelationcoatrxcommon_ds",
								"type": "DatasetReference"
							},
							"name": "RelationDB"
						},
						{
							"dataset": {
								"referenceName": "SQLrelationcoatrxcommon_ds",
								"type": "DatasetReference"
							},
							"name": "RelationDBbeginningbalanceonly"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLrelationcoatrxcommon_ds",
								"type": "DatasetReference"
							},
							"name": "InsertRecords"
						}
					],
					"transformations": [
						{
							"name": "StatgingAddChecksum"
						},
						{
							"name": "LookupRelationalStream"
						},
						{
							"name": "RelationalAddChecksum"
						},
						{
							"name": "ConditionalSplitNewOrExpire"
						},
						{
							"name": "RelationRenameColumns"
						},
						{
							"name": "SelectNewStagingRow"
						},
						{
							"name": "UnionNewTransactions"
						},
						{
							"name": "SelectOutput"
						},
						{
							"name": "SelectDBcolumnsBeginningBalance"
						},
						{
							"name": "IsTrxCodeBeginningBalance"
						},
						{
							"name": "LookupDBbeginningBalance"
						},
						{
							"name": "IsTrxCodeBeginningBalanceExist"
						},
						{
							"name": "SelectBeginingBalanceColumns"
						},
						{
							"name": "AddAuditColumns"
						},
						{
							"name": "AlterRowInsert"
						}
					],
					"script": "parameters{\n\tProcessName as string,\n\tFileName as string,\n\tEtl_Utc_Tag as string\n}\nsource(output(\n\t\tTrx_Code as string,\n\t\tFund_ID as string,\n\t\tAsset_ID as string,\n\t\tGL_Code as string,\n\t\tCash_Flow_Code as string,\n\t\tDebit_Credit as string,\n\t\tTrx_Date as timestamp,\n\t\tTrx_Desc as string,\n\t\tTrx_Type as string,\n\t\tTrx_Amount as decimal(18,2),\n\t\tvalidation_error as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> StagingDB\nsource(output(\n\t\tTrx_ID as long,\n\t\tTrx_Code as string,\n\t\tFund_ID as string,\n\t\tAsset_ID as string,\n\t\tGL_Code as string,\n\t\tCash_Flow_Code as string,\n\t\tDebit_Credit as string,\n\t\tTrx_Type as string,\n\t\tTrx_Date as timestamp,\n\t\tTrx_Desc as string,\n\t\tTrx_Amount as decimal(18,2)\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT DISTINCT TRX.[Trx_ID]\\n      ,TRX.[Trx_Code]\\n      ,TRX.[Fund_ID]\\n      ,TRX.[Asset_ID]\\n      ,TRX.[GL_Code]\\n      ,CASE WHEN COA.GL_Code IS NOT NULL THEN COA.[Cash_Flow_Code] ELSE TRX.Cash_Flow_Code END AS Cash_Flow_Code\\n      ,TRX.[Debit_Credit]\\n      ,TRX.[Trx_Type]\\n      ,TRX.[Trx_Date]\\n      ,TRX.[Trx_Desc]\\n      ,TRX.[Trx_Amount]\\n  FROM [relational].[COA_Transactions] TRX\\n  LEFT JOIN [relational].[Chart_of_Account] COA\\n  ON TRX.GL_Code = COA.GL_Code AND COA.record_deleted_flag = 0\\n  WHERE TRX.[record_deleted_flag] = 0\\n  AND DATEDIFF(DAY,TRX.Update_datetime,CONVERT(smalldatetime,CONVERT(datetimeoffset, SYSDATETIME()) AT TIME ZONE \\'AUS Eastern Standard Time\\')) <= 365',\n\tformat: 'query') ~> RelationDB\nsource(output(\n\t\tTrx_Code as string,\n\t\tFund_ID as string,\n\t\tAsset_ID as string,\n\t\tGL_Code as string,\n\t\tTrx_Type as string,\n\t\tTrx_Date as timestamp,\n\t\tTrx_Desc as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT [Trx_Code]\\n      ,[Fund_ID]\\n      ,[Asset_ID]\\n      ,[GL_Code]\\n      ,[Trx_Type]\\n      ,[Trx_Date]\\n      ,[Trx_Desc]\\n  FROM [relational].[COA_Transactions]\\n  WHERE [record_deleted_flag] = 0\\n  AND [Trx_Type] = \\'Actual\\'\\n  AND [Trx_Desc] = \\'Beginning Balance:\\'',\n\tformat: 'query') ~> RelationDBbeginningbalanceonly\nStagingDB derive(StagingChecksum = sha2(256, Trx_Code,Fund_ID,Asset_ID,GL_Code,Cash_Flow_Code,Trx_Type,Trx_Date,Trx_Desc,Debit_Credit,Trx_Amount)) ~> StatgingAddChecksum\nStatgingAddChecksum, RelationRenameColumns lookup(StagingChecksum == Relation_RelationalChecksum,\n\tmultiple: true,\n\tbroadcast: 'auto')~> LookupRelationalStream\nRelationDB derive(RelationalChecksum = sha2(256, Trx_Code,Fund_ID,Asset_ID,GL_Code,Cash_Flow_Code,Trx_Type,Trx_Date,Trx_Desc,Debit_Credit,Trx_Amount)) ~> RelationalAddChecksum\nLookupRelationalStream split(isNull(Relation_RelationalChecksum),\n\tdisjoint: false) ~> ConditionalSplitNewOrExpire@(StagingNewRow, IgnoreNoChange)\nRelationalAddChecksum select(mapColumn(\n\t\tRelation_Trx_ID = Trx_ID,\n\t\tRelation_Trx_Code = Trx_Code,\n\t\tRelation_Fund_ID = Fund_ID,\n\t\tRelation_Asset_ID = Asset_ID,\n\t\tRelation_GL_Code = GL_Code,\n\t\tRelation_Cash_Flow_Code = Cash_Flow_Code,\n\t\tRelation_Debit_Credit = Debit_Credit,\n\t\tRelation_Trx_Type = Trx_Type,\n\t\tRelation_Trx_Date = Trx_Date,\n\t\tRelation_Trx_Desc = Trx_Desc,\n\t\tRelation_Trx_Amount = Trx_Amount,\n\t\tRelation_RelationalChecksum = RelationalChecksum\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> RelationRenameColumns\nIsTrxCodeBeginningBalance@TrxCodeNotBeginningBalance select(mapColumn(\n\t\tTrx_Code,\n\t\tFund_ID,\n\t\tAsset_ID,\n\t\tGL_Code,\n\t\tCash_Flow_Code,\n\t\tDebit_Credit,\n\t\tTrx_Date,\n\t\tTrx_Desc,\n\t\tTrx_Type,\n\t\tTrx_Amount\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> SelectNewStagingRow\nSelectNewStagingRow, SelectBeginingBalanceColumns union(byName: true)~> UnionNewTransactions\nAddAuditColumns select(mapColumn(\n\t\tTrx_Code,\n\t\tFund_ID,\n\t\tAsset_ID,\n\t\tGL_Code,\n\t\tCash_Flow_Code,\n\t\tDebit_Credit,\n\t\tTrx_Date,\n\t\tTrx_Desc,\n\t\tTrx_Type,\n\t\tTrx_Amount,\n\t\tUpdate_datetime,\n\t\trecord_deleted_flag,\n\t\tprocess_name\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectOutput\nRelationDBbeginningbalanceonly select(mapColumn(\n\t\tRelationBB_Trx_Code = Trx_Code,\n\t\tRelationBB_Fund_ID = Fund_ID,\n\t\tRelationBB_Asset_ID = Asset_ID,\n\t\tRelationBB_GL_Code = GL_Code,\n\t\tRelationBB_Trx_Type = Trx_Type,\n\t\tRelationBB_Trx_Date = Trx_Date,\n\t\tRelationBB_Trx_Desc = Trx_Desc\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectDBcolumnsBeginningBalance\nConditionalSplitNewOrExpire@StagingNewRow split(Trx_Type != 'Actual' || Trx_Desc != 'Beginning Balance:',\n\tdisjoint: false) ~> IsTrxCodeBeginningBalance@(TrxCodeNotBeginningBalance, TrxCodeBeginningBalance)\nIsTrxCodeBeginningBalance@TrxCodeBeginningBalance, SelectDBcolumnsBeginningBalance lookup(Trx_Code == RelationBB_Trx_Code,\n\tmultiple: true,\n\tbroadcast: 'auto')~> LookupDBbeginningBalance\nLookupDBbeginningBalance split(isNull(RelationBB_Trx_Code),\n\tdisjoint: false) ~> IsTrxCodeBeginningBalanceExist@(NewTrxCodeBeginningBalance, ExistingTrxCodeBeginningBalance)\nIsTrxCodeBeginningBalanceExist@NewTrxCodeBeginningBalance select(mapColumn(\n\t\tTrx_Code,\n\t\tFund_ID,\n\t\tAsset_ID,\n\t\tGL_Code,\n\t\tCash_Flow_Code,\n\t\tDebit_Credit,\n\t\tTrx_Date,\n\t\tTrx_Desc,\n\t\tTrx_Type,\n\t\tTrx_Amount\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectBeginingBalanceColumns\nUnionNewTransactions derive(Update_datetime = fromUTC(currentUTC(), 'Australia/Sydney'),\n\t\trecord_deleted_flag = toInteger(0),\n\t\tprocess_name = concatWS('_',$ProcessName,$FileName)) ~> AddAuditColumns\nSelectOutput alterRow(insertIf(record_deleted_flag==0)) ~> AlterRowInsert\nAlterRowInsert sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tinput(\n\t\tTrx_ID as long,\n\t\tTrx_Code as string,\n\t\tFund_ID as string,\n\t\tAsset_ID as string,\n\t\tGL_Code as string,\n\t\tCash_Flow_Code as string,\n\t\tDebit_Credit as string,\n\t\tTrx_Type as string,\n\t\tTrx_Date as timestamp,\n\t\tTrx_Desc as string,\n\t\tTrx_Amount as decimal(18,2),\n\t\tUpdate_datetime as timestamp,\n\t\trecord_deleted_flag as integer,\n\t\tprocess_name as string,\n\t\tStart_Date_Tag as date,\n\t\tEnd_Date_Tag as date\n\t),\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tTrx_Code,\n\t\tFund_ID,\n\t\tAsset_ID,\n\t\tGL_Code,\n\t\tCash_Flow_Code,\n\t\tDebit_Credit,\n\t\tTrx_Type,\n\t\tTrx_Date,\n\t\tTrx_Desc,\n\t\tTrx_Amount,\n\t\tUpdate_datetime,\n\t\trecord_deleted_flag,\n\t\tprocess_name\n\t)) ~> InsertRecords"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadStagingDBtoRelationDB_adjustment_dfx')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "NOTE:This DF only cater for INSERT. There is no Update to Expire for consideration The branch containing \"UpdateSelectForExpire\" kept for reference only",
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "SQLstagingadjustment_ds",
								"type": "DatasetReference"
							},
							"name": "StagingDB"
						},
						{
							"dataset": {
								"referenceName": "SQLrelationcoatrxcommon_ds",
								"type": "DatasetReference"
							},
							"name": "RelationDB"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "DelimitedText_adjustment_loadready_dsx",
								"type": "DatasetReference"
							},
							"name": "InsertUpdateRecords"
						}
					],
					"transformations": [
						{
							"name": "StatgingAddChecksum"
						},
						{
							"name": "LookupRelationalStream"
						},
						{
							"name": "RelationalAddChecksum"
						},
						{
							"name": "ConditionalSplitNewOrExpire"
						},
						{
							"name": "RelationRenameColumns"
						},
						{
							"name": "SelectNewStagingRow"
						},
						{
							"name": "AddAuditColumns"
						},
						{
							"name": "UpdateAddAuditAttributes"
						},
						{
							"name": "AddExpiredAttributes"
						},
						{
							"name": "UpdateSelectForInsert"
						},
						{
							"name": "UnionForDB"
						},
						{
							"name": "UpdateSelectForExpire"
						},
						{
							"name": "SelectOutput"
						}
					],
					"script": "parameters{\n\tProcessName as string,\n\tFileName as string,\n\tEtl_Utc_Tag as string\n}\nsource(output(\n\t\tTrx_Code as string,\n\t\tFund_ID as string,\n\t\tAsset_ID as string,\n\t\tGL_Code as string,\n\t\tCash_Flow_Code as string,\n\t\tDebit_Credit as string,\n\t\tTrx_Date as timestamp,\n\t\tTrx_Desc as string,\n\t\tTrx_Type as string,\n\t\tTrx_Amount as decimal(18,2),\n\t\tvalidation_error as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> StagingDB\nsource(output(\n\t\tTrx_ID as long,\n\t\tTrx_Code as string,\n\t\tFund_ID as string,\n\t\tAsset_ID as string,\n\t\tGL_Code as string,\n\t\tCash_Flow_Code as string,\n\t\tDebit_Credit as string,\n\t\tTrx_Type as string,\n\t\tTrx_Date as timestamp,\n\t\tTrx_Desc as string,\n\t\tTrx_Amount as decimal(18,2),\n\t\tUpdate_datetime as timestamp,\n\t\trecord_deleted_flag as integer,\n\t\tprocess_name as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT [Trx_ID]\\n      ,[Trx_Code]\\n      ,[Fund_ID]\\n      ,[Asset_ID]\\n      ,[GL_Code]\\n      ,[Cash_Flow_Code]\\n      ,[Debit_Credit]\\n      ,[Trx_Type]\\n      ,[Trx_Date]\\n      ,[Trx_Desc]\\n      ,[Trx_Amount]\\n      ,[Update_datetime]\\n      ,[record_deleted_flag]\\n      ,[process_name]\\n  FROM [relational].[COA_Transactions]\\n  WHERE [Trx_Type] != \\'Actual\\'\\n  AND[record_deleted_flag] = 0',\n\tformat: 'query') ~> RelationDB\nStagingDB derive(StagingChecksum = sha2(256, Trx_Code,Fund_ID,Asset_ID,GL_Code,Cash_Flow_Code,Trx_Type,Trx_Date,Trx_Desc,Debit_Credit,Trx_Amount)) ~> StatgingAddChecksum\nStatgingAddChecksum, RelationRenameColumns lookup(StagingChecksum == Relation_RelationalChecksum,\n\tmultiple: true,\n\tbroadcast: 'auto')~> LookupRelationalStream\nRelationDB derive(RelationalChecksum = sha2(256, Trx_Code,Fund_ID,Asset_ID,GL_Code,Cash_Flow_Code,Trx_Type,Trx_Date,Trx_Desc,Debit_Credit,Trx_Amount)) ~> RelationalAddChecksum\nLookupRelationalStream split(isNull(Relation_RelationalChecksum),\n\tDebit_Credit!=Relation_Debit_Credit || Trx_Amount!=Relation_Trx_Amount,\n\tdisjoint: false) ~> ConditionalSplitNewOrExpire@(StagingNewRow, StagingChangedRow, IgnoreNoChange)\nRelationalAddChecksum select(mapColumn(\n\t\tRelation_Trx_ID = Trx_ID,\n\t\tRelation_Trx_Code = Trx_Code,\n\t\tRelation_Fund_ID = Fund_ID,\n\t\tRelation_Asset_ID = Asset_ID,\n\t\tRelation_GL_Code = GL_Code,\n\t\tRelation_Cash_Flow_Code = Cash_Flow_Code,\n\t\tRelation_Debit_Credit = Debit_Credit,\n\t\tRelation_Trx_Type = Trx_Type,\n\t\tRelation_Trx_Date = Trx_Date,\n\t\tRelation_Trx_Desc = Trx_Desc,\n\t\tRelation_Trx_Amount = Trx_Amount,\n\t\tRelation_Update_datetime = Update_datetime,\n\t\tRelation_record_deleted_flag = record_deleted_flag,\n\t\tRelation_process_name = process_name,\n\t\tRelation_RelationalChecksum = RelationalChecksum\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> RelationRenameColumns\nConditionalSplitNewOrExpire@StagingNewRow select(mapColumn(\n\t\tTrx_Code,\n\t\tFund_ID,\n\t\tAsset_ID,\n\t\tGL_Code,\n\t\tCash_Flow_Code,\n\t\tDebit_Credit,\n\t\tTrx_Date,\n\t\tTrx_Desc,\n\t\tTrx_Type,\n\t\tTrx_Amount\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> SelectNewStagingRow\nSelectNewStagingRow derive(Update_datetime = fromUTC(currentUTC(), 'Australia/Sydney'),\n\t\trecord_deleted_flag = toInteger(0),\n\t\tprocess_name = concatWS('-',$ProcessName,$FileName),\n\t\tinsert_update_flag = toString('I'),\n\t\tTrx_ID = toLong(null())) ~> AddAuditColumns\nConditionalSplitNewOrExpire@StagingChangedRow derive(Update_datetime = fromUTC(currentUTC(), 'Australia/Sydney'),\n\t\trecord_deleted_flag = toInteger(0),\n\t\tprocess_name = concatWS('-', $ProcessName, $FileName),\n\t\tinsert_update_flag = toString('I'),\n\t\tTrx_ID = toLong(null())) ~> UpdateAddAuditAttributes\nConditionalSplitNewOrExpire@StagingChangedRow derive(record_deleted_flag = toInteger(1),\n\t\tinsert_update_flag = toString('U')) ~> AddExpiredAttributes\nUpdateAddAuditAttributes select(mapColumn(\n\t\tTrx_Code,\n\t\tFund_ID,\n\t\tAsset_ID,\n\t\tGL_Code,\n\t\tDebit_Credit,\n\t\tTrx_Type,\n\t\tTrx_Date,\n\t\tTrx_Desc,\n\t\tTrx_Amount,\n\t\tCash_Flow_Code,\n\t\tUpdate_datetime,\n\t\trecord_deleted_flag,\n\t\tprocess_name,\n\t\tTrx_ID,\n\t\tinsert_update_flag\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> UpdateSelectForInsert\nAddAuditColumns union(byName: true)~> UnionForDB\nAddExpiredAttributes select(mapColumn(\n\t\tTrx_Code = Relation_Trx_Code,\n\t\tFund_ID = Relation_Fund_ID,\n\t\tAsset_ID = Relation_Asset_ID,\n\t\tGL_Code = Relation_GL_Code,\n\t\tCash_Flow_Code = Relation_Cash_Flow_Code,\n\t\tDebit_Credit = Relation_Debit_Credit,\n\t\tTrx_Type = Relation_Trx_Type,\n\t\tTrx_Date = Relation_Trx_Date,\n\t\tTrx_Desc = Relation_Trx_Desc,\n\t\tTrx_Amount = Relation_Trx_Amount,\n\t\tprocess_name = Relation_process_name,\n\t\tUpdate_datetime = Relation_Update_datetime,\n\t\trecord_deleted_flag,\n\t\tTrx_ID = Relation_Trx_ID,\n\t\tinsert_update_flag\n\t),\n\tpartitionBy('hash', 1),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> UpdateSelectForExpire\nUnionForDB select(mapColumn(\n\t\tTrx_Code,\n\t\tFund_ID,\n\t\tAsset_ID,\n\t\tGL_Code,\n\t\tCash_Flow_Code,\n\t\tDebit_Credit,\n\t\tTrx_Date,\n\t\tTrx_Desc,\n\t\tTrx_Type,\n\t\tTrx_Amount,\n\t\tTrx_ID,\n\t\tUpdate_datetime,\n\t\trecord_deleted_flag,\n\t\tprocess_name,\n\t\tinsert_update_flag\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectOutput\nSelectOutput sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tinput(\n\t\tTrx_Code as string,\n\t\tFund_ID as string,\n\t\tAsset_ID as string,\n\t\tGL_Code as string,\n\t\tCash_Flow_Code as string,\n\t\tDebit_Credit as string,\n\t\tTrx_Date as string,\n\t\tTrx_Desc as string,\n\t\tTrx_Type as string,\n\t\tTrx_Amount as string,\n\t\tTrx_ID as string,\n\t\tUpdate_datetime as string,\n\t\trecord_deleted_flag as string,\n\t\tprocess_name as string,\n\t\tinsert_update_flag as string\n\t),\n\tpartitionFileNames:['AdjustmentLoadReadyFile.txt'],\n\tmapColumn(\n\t\tTrx_Code,\n\t\tFund_ID,\n\t\tAsset_ID,\n\t\tGL_Code,\n\t\tCash_Flow_Code,\n\t\tDebit_Credit,\n\t\tTrx_Date,\n\t\tTrx_Desc,\n\t\tTrx_Type,\n\t\tTrx_Amount,\n\t\tTrx_ID,\n\t\tUpdate_datetime,\n\t\trecord_deleted_flag,\n\t\tprocess_name,\n\t\tinsert_update_flag\n\t),\n\tpartitionBy('hash', 1)) ~> InsertUpdateRecords"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadStagingDBtoRelationDB_adjustment_n_actual_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"description": "NOTE:This DF only cater for INSERT. There is no Update to Expire for consideration The branch containing \"UpdateSelectForExpire\" kept for reference only\nCheck for Beginning Balance is deprecated but remained in DF in case we ever need to use it again",
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "SQLstagingadjustment_ds",
								"type": "DatasetReference"
							},
							"name": "StagingDB"
						},
						{
							"dataset": {
								"referenceName": "SQLrelationcoatrxcommon_ds",
								"type": "DatasetReference"
							},
							"name": "RelationDB"
						},
						{
							"dataset": {
								"referenceName": "SQLrelationcoatrxcommon_ds",
								"type": "DatasetReference"
							},
							"name": "RelationDBbeginningbalanceonly"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLrelationcoatrxcommon_ds",
								"type": "DatasetReference"
							},
							"name": "InsertRecords"
						}
					],
					"transformations": [
						{
							"name": "StatgingAddChecksum"
						},
						{
							"name": "LookupRelationalStream"
						},
						{
							"name": "RelationalAddChecksum"
						},
						{
							"name": "ConditionalSplitNewOrExpire"
						},
						{
							"name": "RelationRenameColumns"
						},
						{
							"name": "SelectNewStagingRow"
						},
						{
							"name": "UnionNewTransactions"
						},
						{
							"name": "SelectOutput"
						},
						{
							"name": "SelectDBcolumnsBeginningBalance"
						},
						{
							"name": "IsTrxCodeBeginningBalance"
						},
						{
							"name": "LookupDBbeginningBalance"
						},
						{
							"name": "IsTrxCodeBeginningBalanceExist"
						},
						{
							"name": "SelectBeginingBalanceColumns"
						},
						{
							"name": "AddAuditColumns"
						},
						{
							"name": "AlterRowInsert"
						}
					],
					"script": "parameters{\n\tProcessName as string,\n\tFileName as string,\n\tEtl_Utc_Tag as string\n}\nsource(output(\n\t\tTrx_Code as string,\n\t\tFund_ID as string,\n\t\tAsset_ID as string,\n\t\tGL_Code as string,\n\t\tCash_Flow_Code as string,\n\t\tDebit_Credit as string,\n\t\tTrx_Date as timestamp,\n\t\tTrx_Desc as string,\n\t\tTrx_Type as string,\n\t\tTrx_Amount as decimal(18,2),\n\t\tvalidation_error as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> StagingDB\nsource(output(\n\t\tTrx_ID as long,\n\t\tTrx_Code as string,\n\t\tFund_ID as string,\n\t\tAsset_ID as string,\n\t\tGL_Code as string,\n\t\tCash_Flow_Code as string,\n\t\tDebit_Credit as string,\n\t\tTrx_Type as string,\n\t\tTrx_Date as timestamp,\n\t\tTrx_Desc as string,\n\t\tTrx_Amount as decimal(18,2)\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT DISTINCT TRX.[Trx_ID]\\n      ,TRX.[Trx_Code]\\n      ,TRX.[Fund_ID]\\n      ,TRX.[Asset_ID]\\n      ,TRX.[GL_Code]\\n      ,TRX.Cash_Flow_Code\\n      ,TRX.[Debit_Credit]\\n      ,TRX.[Trx_Type]\\n      ,TRX.[Trx_Date]\\n      ,TRX.[Trx_Desc]\\n      ,TRX.[Trx_Amount]\\n  FROM [relational].[COA_Transactions] TRX\\n  LEFT JOIN [relational].[Chart_of_Account] COA\\n  ON TRX.GL_Code = COA.GL_Code AND COA.record_deleted_flag = 0\\n  WHERE TRX.[record_deleted_flag] = 0\\n  AND DATEDIFF(DAY,TRX.Update_datetime,CONVERT(smalldatetime,CONVERT(datetimeoffset, SYSDATETIME()) AT TIME ZONE \\'AUS Eastern Standard Time\\')) <= 365',\n\tformat: 'query') ~> RelationDB\nsource(output(\n\t\tTrx_Code as string,\n\t\tFund_ID as string,\n\t\tAsset_ID as string,\n\t\tGL_Code as string,\n\t\tTrx_Type as string,\n\t\tTrx_Date as timestamp,\n\t\tTrx_Desc as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT [Trx_Code]\\n      ,[Fund_ID]\\n      ,[Asset_ID]\\n      ,[GL_Code]\\n      ,[Trx_Type]\\n      ,[Trx_Date]\\n      ,[Trx_Desc]\\n  FROM [relational].[COA_Transactions]\\n  WHERE [record_deleted_flag] = 0\\n  AND [Trx_Type] = \\'Actual\\'\\n  AND [Trx_Desc] = \\'Beginning Balance:\\'',\n\tformat: 'query') ~> RelationDBbeginningbalanceonly\nStagingDB derive(StagingChecksum = sha2(256, Trx_Code,Fund_ID,Asset_ID,GL_Code,Cash_Flow_Code,Trx_Type,Trx_Date,Trx_Desc,Debit_Credit,Trx_Amount)) ~> StatgingAddChecksum\nStatgingAddChecksum, RelationRenameColumns lookup(StagingChecksum == Relation_RelationalChecksum,\n\tmultiple: true,\n\tbroadcast: 'auto')~> LookupRelationalStream\nRelationDB derive(RelationalChecksum = sha2(256, Trx_Code,Fund_ID,Asset_ID,GL_Code,Cash_Flow_Code,Trx_Type,Trx_Date,Trx_Desc,Debit_Credit,Trx_Amount)) ~> RelationalAddChecksum\nLookupRelationalStream split(isNull(Relation_RelationalChecksum),\n\tdisjoint: false) ~> ConditionalSplitNewOrExpire@(StagingNewRow, IgnoreNoChange)\nRelationalAddChecksum select(mapColumn(\n\t\tRelation_Trx_ID = Trx_ID,\n\t\tRelation_Trx_Code = Trx_Code,\n\t\tRelation_Fund_ID = Fund_ID,\n\t\tRelation_Asset_ID = Asset_ID,\n\t\tRelation_GL_Code = GL_Code,\n\t\tRelation_Cash_Flow_Code = Cash_Flow_Code,\n\t\tRelation_Debit_Credit = Debit_Credit,\n\t\tRelation_Trx_Type = Trx_Type,\n\t\tRelation_Trx_Date = Trx_Date,\n\t\tRelation_Trx_Desc = Trx_Desc,\n\t\tRelation_Trx_Amount = Trx_Amount,\n\t\tRelation_RelationalChecksum = RelationalChecksum\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> RelationRenameColumns\nIsTrxCodeBeginningBalance@AllRecordsIncludeBeginningBalance select(mapColumn(\n\t\tTrx_Code,\n\t\tFund_ID,\n\t\tAsset_ID,\n\t\tGL_Code,\n\t\tCash_Flow_Code,\n\t\tDebit_Credit,\n\t\tTrx_Date,\n\t\tTrx_Desc,\n\t\tTrx_Type,\n\t\tTrx_Amount\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> SelectNewStagingRow\nSelectNewStagingRow, SelectBeginingBalanceColumns union(byName: true)~> UnionNewTransactions\nAddAuditColumns select(mapColumn(\n\t\tTrx_Code,\n\t\tFund_ID,\n\t\tAsset_ID,\n\t\tGL_Code,\n\t\tCash_Flow_Code,\n\t\tDebit_Credit,\n\t\tTrx_Date,\n\t\tTrx_Desc,\n\t\tTrx_Type,\n\t\tTrx_Amount,\n\t\tUpdate_datetime,\n\t\trecord_deleted_flag,\n\t\tprocess_name\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectOutput\nRelationDBbeginningbalanceonly select(mapColumn(\n\t\tRelationBB_Trx_Code = Trx_Code,\n\t\tRelationBB_Fund_ID = Fund_ID,\n\t\tRelationBB_Asset_ID = Asset_ID,\n\t\tRelationBB_GL_Code = GL_Code,\n\t\tRelationBB_Trx_Type = Trx_Type,\n\t\tRelationBB_Trx_Date = Trx_Date,\n\t\tRelationBB_Trx_Desc = Trx_Desc\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectDBcolumnsBeginningBalance\nConditionalSplitNewOrExpire@StagingNewRow split(true(),\n\tdisjoint: false) ~> IsTrxCodeBeginningBalance@(AllRecordsIncludeBeginningBalance, DeprecatedTrxCodeBeginningBalance)\nIsTrxCodeBeginningBalance@DeprecatedTrxCodeBeginningBalance, SelectDBcolumnsBeginningBalance lookup(Trx_Code == RelationBB_Trx_Code,\n\tmultiple: true,\n\tbroadcast: 'auto')~> LookupDBbeginningBalance\nLookupDBbeginningBalance split(isNull(RelationBB_Trx_Code),\n\tdisjoint: false) ~> IsTrxCodeBeginningBalanceExist@(NewTrxCodeBeginningBalance, ExistingTrxCodeBeginningBalance)\nIsTrxCodeBeginningBalanceExist@NewTrxCodeBeginningBalance select(mapColumn(\n\t\tTrx_Code,\n\t\tFund_ID,\n\t\tAsset_ID,\n\t\tGL_Code,\n\t\tCash_Flow_Code,\n\t\tDebit_Credit,\n\t\tTrx_Date,\n\t\tTrx_Desc,\n\t\tTrx_Type,\n\t\tTrx_Amount\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectBeginingBalanceColumns\nUnionNewTransactions derive(Update_datetime = fromUTC(currentUTC(), 'Australia/Sydney'),\n\t\trecord_deleted_flag = toInteger(0),\n\t\tprocess_name = concatWS('_',$ProcessName,$FileName)) ~> AddAuditColumns\nSelectOutput alterRow(insertIf(record_deleted_flag==0)) ~> AlterRowInsert\nAlterRowInsert sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tinput(\n\t\tTrx_ID as long,\n\t\tTrx_Code as string,\n\t\tFund_ID as string,\n\t\tAsset_ID as string,\n\t\tGL_Code as string,\n\t\tCash_Flow_Code as string,\n\t\tDebit_Credit as string,\n\t\tTrx_Type as string,\n\t\tTrx_Date as timestamp,\n\t\tTrx_Desc as string,\n\t\tTrx_Amount as decimal(18,2),\n\t\tUpdate_datetime as timestamp,\n\t\trecord_deleted_flag as integer,\n\t\tprocess_name as string,\n\t\tStart_Date_Tag as date,\n\t\tEnd_Date_Tag as date\n\t),\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tTrx_Code,\n\t\tFund_ID,\n\t\tAsset_ID,\n\t\tGL_Code,\n\t\tCash_Flow_Code,\n\t\tDebit_Credit,\n\t\tTrx_Type,\n\t\tTrx_Date,\n\t\tTrx_Desc,\n\t\tTrx_Amount,\n\t\tUpdate_datetime,\n\t\trecord_deleted_flag,\n\t\tprocess_name\n\t)) ~> InsertRecords"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadStagingDBtoRelationDB_asset_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "SQLstagingasset_ds",
								"type": "DatasetReference"
							},
							"name": "StagingDB"
						},
						{
							"dataset": {
								"referenceName": "SQLrelationasset_ds",
								"type": "DatasetReference"
							},
							"name": "RelationDB"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLrelationasset_ds",
								"type": "DatasetReference"
							},
							"name": "InsertUpdateRow"
						}
					],
					"transformations": [
						{
							"name": "StatgingAddChecksum"
						},
						{
							"name": "LookupRelationalStream"
						},
						{
							"name": "RelationalAddChecksum"
						},
						{
							"name": "ConditionalSplitNewOrExpire"
						},
						{
							"name": "RelationRenameColumns"
						},
						{
							"name": "SelectNewStagingRow"
						},
						{
							"name": "AddAuditColumns"
						},
						{
							"name": "AlterRowInsertUpdateExpire"
						},
						{
							"name": "UpdateAddAuditAttributes"
						},
						{
							"name": "AddExpiredAttributes"
						},
						{
							"name": "UpdateSelectForInsert"
						},
						{
							"name": "UnionForDB"
						},
						{
							"name": "UpdateSelectForExpire"
						}
					],
					"script": "parameters{\n\tProcessName as string,\n\tFileName as string,\n\tEtl_Utc_Tag as string\n}\nsource(output(\n\t\tAsset_ID as string,\n\t\tAsset_Name as string,\n\t\tAsset_Curency as string,\n\t\tFund_ID as string,\n\t\tAsset_Alloc_Per as decimal(18,2),\n\t\tAsset_country as string,\n\t\tFund_Region as string,\n\t\tFund_State as string,\n\t\tProp_Mgr_Name as string,\n\t\tProp_Mgr_Company as string,\n\t\tRH_Level_1 as string,\n\t\tRH_Level_2 as string,\n\t\tRH_Level_3 as string,\n\t\tRH_Level_4 as string,\n\t\tRH_Level_5 as string,\n\t\tOps_Representative_First_Name as string,\n\t\tOps_Representative_Last_Name as string,\n\t\tOps_Representative_Email as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tformat: 'table') ~> StagingDB\nsource(output(\n\t\tAsset_ID as string,\n\t\tAsset_Name as string,\n\t\tAsset_Curency as string,\n\t\tFund_ID as string,\n\t\tAsset_Alloc_Per as decimal(18,2),\n\t\tAsset_country as string,\n\t\tFund_Region as string,\n\t\tFund_State as string,\n\t\tProp_Mgr_Name as string,\n\t\tProp_Mgr_Company as string,\n\t\tstart_datetime as timestamp,\n\t\tprocess_name as string,\n\t\tRH_Level_1 as string,\n\t\tRH_Level_2 as string,\n\t\tRH_Level_3 as string,\n\t\tRH_Level_4 as string,\n\t\tRH_Level_5 as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: ' SELECT [Asset_ID]\\n\t,[Asset_Name]\\n\t,[Asset_Curency]\\n\t,[Fund_ID]\\n\t,[Asset_Alloc_Per]\\n\t,[Asset_country]\\n\t,[Fund_Region]\\n\t,[Fund_State]\\n\t,[Prop_Mgr_Name]\\n\t,[Prop_Mgr_Company]\\n    ,[start_datetime]\\n\t,[process_name]\\n\t,[RH_Level_1]\\n\t,[RH_Level_2]\\n\t,[RH_Level_3]\\n\t,[RH_Level_4]\\n\t,[RH_Level_5]\\nFROM [relational].[Asset]\\nWHERE [record_deleted_flag] = 0',\n\tformat: 'query') ~> RelationDB\nStagingDB derive(StagingChecksum = sha2(256, Asset_ID,Asset_Name,Asset_Curency,Fund_ID,Asset_Alloc_Per,Asset_country,Fund_Region,Fund_State,Prop_Mgr_Name,Prop_Mgr_Company,RH_Level_1,RH_Level_2,RH_Level_3,RH_Level_4,RH_Level_5)) ~> StatgingAddChecksum\nStatgingAddChecksum, RelationRenameColumns lookup(Asset_ID == Relation_Asset_ID\n\t&& Fund_ID == Relation_Fund_ID,\n\tmultiple: true,\n\tbroadcast: 'auto')~> LookupRelationalStream\nRelationDB derive(RelationalChecksum = sha2(256, Asset_ID,Asset_Name,Asset_Curency,Fund_ID,Asset_Alloc_Per,Asset_country,Fund_Region,Fund_State,Prop_Mgr_Name,Prop_Mgr_Company,RH_Level_1,RH_Level_2,RH_Level_3,RH_Level_4,RH_Level_5)) ~> RelationalAddChecksum\nLookupRelationalStream split(isNull(Relation_RelationalChecksum),\n\tStagingChecksum != Relation_RelationalChecksum || Asset_Alloc_Per != Relation_Asset_Alloc_Per,\n\tdisjoint: false) ~> ConditionalSplitNewOrExpire@(StagingNewRow, StagingChangedRow, IgnoreNoChange)\nRelationalAddChecksum select(mapColumn(\n\t\tRelation_Asset_ID = Asset_ID,\n\t\tRelation_Asset_Name = Asset_Name,\n\t\tRelation_Asset_Curency = Asset_Curency,\n\t\tRelation_Fund_ID = Fund_ID,\n\t\tRelation_Asset_Alloc_Per = Asset_Alloc_Per,\n\t\tRelation_Asset_country = Asset_country,\n\t\tRelation_Fund_Region = Fund_Region,\n\t\tRelation_Fund_State = Fund_State,\n\t\tRelation_Prop_Mgr_Name = Prop_Mgr_Name,\n\t\tRelation_Prop_Mgr_Company = Prop_Mgr_Company,\n\t\tRelation_start_datetime = start_datetime,\n\t\tRelation_process_name = process_name,\n\t\tRelation_RH_Level_1 = RH_Level_1,\n\t\tRelation_RH_Level_2 = RH_Level_2,\n\t\tRelation_RH_Level_3 = RH_Level_3,\n\t\tRelation_RH_Level_4 = RH_Level_4,\n\t\tRelation_RH_Level_5 = RH_Level_5,\n\t\tRelation_RelationalChecksum = RelationalChecksum\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> RelationRenameColumns\nConditionalSplitNewOrExpire@StagingNewRow select(mapColumn(\n\t\tAsset_ID,\n\t\tAsset_Name,\n\t\tAsset_Curency,\n\t\tFund_ID,\n\t\tAsset_Alloc_Per,\n\t\tAsset_country,\n\t\tFund_Region,\n\t\tFund_State,\n\t\tProp_Mgr_Name,\n\t\tProp_Mgr_Company,\n\t\tRH_Level_1,\n\t\tRH_Level_2,\n\t\tRH_Level_3,\n\t\tRH_Level_4,\n\t\tRH_Level_5,\n\t\tOps_Representative_First_Name,\n\t\tOps_Representative_Last_Name,\n\t\tOps_Representative_Email\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> SelectNewStagingRow\nSelectNewStagingRow derive(start_datetime = fromUTC(currentUTC(), 'Australia/Sydney'),\n\t\tend_datetime = toTimestamp('9999-12-31 00:00:00'),\n\t\trecord_deleted_flag = toInteger(0),\n\t\tprocess_name = concatWS('_',$ProcessName,$FileName)) ~> AddAuditColumns\nUnionForDB alterRow(insertIf(record_deleted_flag==toInteger(0)),\n\tupdateIf(record_deleted_flag==toInteger(1))) ~> AlterRowInsertUpdateExpire\nConditionalSplitNewOrExpire@StagingChangedRow derive(start_datetime = fromUTC(currentUTC(), 'Australia/Sydney'),\n\t\tend_datetime = toTimestamp('9999-12-31 00:00:00'),\n\t\trecord_deleted_flag = toInteger(0),\n\t\tprocess_name = concatWS('_',$ProcessName,$FileName)) ~> UpdateAddAuditAttributes\nConditionalSplitNewOrExpire@StagingChangedRow derive(end_datetime = fromUTC(currentUTC(), 'Australia/Sydney'),\n\t\trecord_deleted_flag = toInteger(1)) ~> AddExpiredAttributes\nUpdateAddAuditAttributes select(mapColumn(\n\t\tAsset_ID,\n\t\tAsset_Name,\n\t\tAsset_Curency,\n\t\tFund_ID,\n\t\tAsset_Alloc_Per,\n\t\tAsset_country,\n\t\tFund_Region,\n\t\tFund_State,\n\t\tProp_Mgr_Name,\n\t\tProp_Mgr_Company,\n\t\tstart_datetime,\n\t\tend_datetime,\n\t\trecord_deleted_flag,\n\t\tprocess_name,\n\t\tRH_Level_1,\n\t\tRH_Level_2,\n\t\tRH_Level_3,\n\t\tRH_Level_4,\n\t\tRH_Level_5,\n\t\tOps_Representative_First_Name,\n\t\tOps_Representative_Last_Name,\n\t\tOps_Representative_Email\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> UpdateSelectForInsert\nAddAuditColumns, UpdateSelectForInsert, UpdateSelectForExpire union(byName: true)~> UnionForDB\nAddExpiredAttributes select(mapColumn(\n\t\tAsset_ID = Relation_Asset_ID,\n\t\tAsset_Name = Relation_Asset_Name,\n\t\tAsset_Curency = Relation_Asset_Curency,\n\t\tFund_ID = Relation_Fund_ID,\n\t\tAsset_Alloc_Per = Relation_Asset_Alloc_Per,\n\t\tAsset_country = Relation_Asset_country,\n\t\tFund_Region = Relation_Fund_Region,\n\t\tFund_State = Relation_Fund_State,\n\t\tProp_Mgr_Name = Relation_Prop_Mgr_Name,\n\t\tProp_Mgr_Company = Relation_Prop_Mgr_Company,\n\t\tstart_datetime = Relation_start_datetime,\n\t\tprocess_name = Relation_process_name,\n\t\tend_datetime,\n\t\trecord_deleted_flag,\n\t\tRH_Level_1 = Relation_RH_Level_1,\n\t\tRH_Level_2 = Relation_RH_Level_2,\n\t\tRH_Level_3 = Relation_RH_Level_3,\n\t\tRH_Level_4 = Relation_RH_Level_4,\n\t\tRH_Level_5 = Relation_RH_Level_5,\n\t\tOps_Representative_First_Name,\n\t\tOps_Representative_Last_Name,\n\t\tOps_Representative_Email\n\t),\n\tskipDuplicateMapInputs: false,\n\tskipDuplicateMapOutputs: false) ~> UpdateSelectForExpire\nAlterRowInsertUpdateExpire sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tinput(\n\t\tAsset_ID as string,\n\t\tAsset_Name as string,\n\t\tAsset_Curency as string,\n\t\tFund_ID as string,\n\t\tAsset_Alloc_Per as decimal(18,2),\n\t\tAsset_country as string,\n\t\tFund_Region as string,\n\t\tFund_State as string,\n\t\tProp_Mgr_Name as string,\n\t\tProp_Mgr_Company as string,\n\t\tstart_datetime as timestamp,\n\t\tend_datetime as timestamp,\n\t\trecord_deleted_flag as integer,\n\t\tprocess_name as string,\n\t\tRH_Level_1 as string,\n\t\tRH_Level_2 as string,\n\t\tRH_Level_3 as string,\n\t\tRH_Level_4 as string,\n\t\tRH_Level_5 as string,\n\t\tOps_Representative_First_Name as string,\n\t\tOps_Representative_Last_Name as string,\n\t\tOps_Representative_Email as string\n\t),\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['Asset_ID','Fund_ID','process_name'],\n\tformat: 'table',\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tAsset_ID,\n\t\tAsset_Name,\n\t\tAsset_Curency,\n\t\tFund_ID,\n\t\tAsset_Alloc_Per,\n\t\tAsset_country,\n\t\tFund_Region,\n\t\tFund_State,\n\t\tProp_Mgr_Name,\n\t\tProp_Mgr_Company,\n\t\tstart_datetime,\n\t\tend_datetime,\n\t\trecord_deleted_flag,\n\t\tprocess_name,\n\t\tRH_Level_1,\n\t\tRH_Level_2,\n\t\tRH_Level_3,\n\t\tRH_Level_4,\n\t\tRH_Level_5,\n\t\tOps_Representative_First_Name,\n\t\tOps_Representative_Last_Name,\n\t\tOps_Representative_Email\n\t)) ~> InsertUpdateRow"
				}
			},
			"dependsOn": []
		}
	]
}