{
	"$schema": "http://schema.management.azure.com/schemas/2015-01-01/deploymentTemplate.json#",
	"contentVersion": "1.0.0.0",
	"parameters": {
		"factoryName": {
			"type": "string",
			"metadata": "Data Factory name",
			"defaultValue": "DWH-NonProd-ADF"
		}
	},
	"variables": {
		"factoryId": "[concat('Microsoft.DataFactory/factories/', parameters('factoryName'))]"
	},
	"resources": [
		{
			"name": "[concat(parameters('factoryName'), '/LoadXlsxHarvestReconcilliation_Step1_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ParquetPersistentOpsWithTabParam_ds",
								"type": "DatasetReference"
							},
							"name": "SourceDataTab"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGeneric_ds",
								"type": "DatasetReference"
							},
							"name": "RelationalOperationType"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGeneric_ds",
								"type": "DatasetReference"
							},
							"name": "RelationalSpeciesType"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ParquetPersistentOps_ds",
								"type": "DatasetReference"
							},
							"name": "TargetPersistentParquetInsert"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "ErrorTable"
						}
					],
					"transformations": [
						{
							"name": "ValidateMandatoryColumns",
							"description": "ReportingDateCertificationIDValidateMsg is a test and should be considered as part of the conditional split Insert/Update activity"
						},
						{
							"name": "SegregateValidInvalidRows"
						},
						{
							"name": "SelectedColumnsOutputInsert"
						},
						{
							"name": "ConcatenateInvalidColumnsMessage"
						},
						{
							"name": "SelectedOutputColumnsError"
						},
						{
							"name": "GenerateRowNumber"
						},
						{
							"name": "ExcludeFirstRow"
						},
						{
							"name": "DateTypeTransform"
						},
						{
							"name": "SelectOperationTypeLkp"
						},
						{
							"name": "LookupOperationType"
						},
						{
							"name": "SelectSpeciesTypeLkp"
						},
						{
							"name": "LookupSpeciesType"
						}
					],
					"script": "parameters{\n\tMasterUtcTag as string,\n\tCurrentRunDateTime as string,\n\tWorkbookName as string,\n\tTabName as string,\n\tCurrentQuarterDate as string,\n\tMasterPipeline as string\n}\nsource(output(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tReporting_Period as string,\n\t\tValidation_Flag as string,\n\t\tHarvest_Unit as string,\n\t\tHarvest_Operation_Type as string,\n\t\tProduct as string,\n\t\tSpecies as string,\n\t\tTotal_Net_Stocked_Area_of_Harvest_Unit as string,\n\t\tActual_Harvest_Commencement as string,\n\t\tPredicted_Harvested_GMT as string,\n\t\tPredicted_Revenue as string,\n\t\tPredicted_Stumpage as string,\n\t\tPredicted_Sales_Expense_Fees_Levies_etc as string,\n\t\tPredicted_Sales_Expense_Cartage as string,\n\t\tPredicted_Sales_Expense_Harvesting as string,\n\t\tPredicted_Sales_Expense_Roading_Capex_Maintenance as string,\n\t\tPredicted_Sales_Expense_Other as string,\n\t\tActual_Date_of_Reconciliation as string,\n\t\tActual_Revenue as string,\n\t\tActual_Harvested_GMT as string,\n\t\tActual_Harvested_Net_Stocked_Area as string,\n\t\tActual_Sales_Expense_Managers_Fees_Levies as string,\n\t\tActual_Sales_Expense_Cartage as string,\n\t\tActual_Sales_Expense_Harvesting as string,\n\t\tActual_Sales_Expense_Roading_Capex_Maintenance as string,\n\t\tActual_Sales_Expense_Other as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\tformat: 'parquet',\n\tpartitionBy('hash', 1)) ~> SourceDataTab\nsource(output(\n\t\tOperation_Type_Code as string,\n\t\tOperation_Type as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT DISTINCT [Operation_Type_Code]\\n      ,[Operation_Type]\\n  FROM [relational].[OPS_Operation_Type]\\nWHERE [Active_YN] = \\'Y\\'',\n\tformat: 'query',\n\tpartitionBy('hash', 1)) ~> RelationalOperationType\nsource(output(\n\t\tSpecies_Code as string,\n\t\tSpecies as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT DISTINCT [Species_Code]\\n      ,[Species]\\n FROM [relational].[OPS_Species_Type]\\n WHERE [Active_YN] = \\'Y\\'',\n\tformat: 'query') ~> RelationalSpeciesType\nLookupSpeciesType derive(OperationTypeValidateMsg = iif(isNull(Operation_Type_Code_Lkp), \"Operation Type/\", \"\"),\n\t\tSpeciesTypeValidateMsg = iif(isNull(Species_Code_Lkp), \"Species Type/\", \"\"),\n\t\tPredictedHarvestedGmtValidateMssg = iif(not(isNull(Predicted_Harvested_GMT)),iif(not(isNull(Predicted_Harvested_GMT_toDecimal)),\"\",\"Predicted Harvested GMT/\"),\"Predicted Harvested GMT/\"),\n\t\tActualHarvestedGmtValidateMsg = iif(not(isNull(Actual_Harvested_GMT)),iif(not(isNull(Actual_Harvested_GMT_toDecimal)),\"\",\"Actual Harvested GMT/\"),\"Actual Harvested GMT/\"),\n\t\tActualHarvestCommencementValidateMsg = iif(not(isNull(Actual_Harvest_Commencement)),iif(not(isNull(Actual_Harvest_Commencement_toDate)),\"\",\"Actual Harvest Commencement/\"),\"Actual Harvest Commencement/\"),\n\t\tAssetReportingDateValidateMsg = iif(isNull(Asset_ID) || isNull(Fund_ID) || isNull(Reporting_Period), \"Invalid Asset or Reporting Period/\", \"\")) ~> ValidateMandatoryColumns\nValidateMandatoryColumns split(length(concatWS('',OperationTypeValidateMsg, SpeciesTypeValidateMsg, PredictedHarvestedGmtValidateMssg, ActualHarvestedGmtValidateMsg, ActualHarvestCommencementValidateMsg,AssetReportingDateValidateMsg)) == 0,\n\tdisjoint: false) ~> SegregateValidInvalidRows@(ValidRows, InvalidRows)\nSegregateValidInvalidRows@ValidRows select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tHarvest_Unit,\n\t\tOperation_Type_Code = Operation_Type_Code_Lkp,\n\t\tProduct_Code = Product,\n\t\tSpecies_Code = Species_Code_Lkp,\n\t\tTotal_Net_Stocked_Area_of_Harvest_Unit,\n\t\tPredicted_Harvested_GMT = Predicted_Harvested_GMT_toDecimal,\n\t\tPredicted_Revenue,\n\t\tPredicted_Stumpage,\n\t\tActual_Harvest_Commencement = Actual_Harvest_Commencement_toDate,\n\t\tActual_Date_of_Reconcilation = Actual_Date_of_Reconciliation,\n\t\tActual_Harvested_Net_Stocked_Area,\n\t\tActual_Harvested_GMT = Actual_Harvested_GMT_toDecimal,\n\t\tActual_Revenue,\n\t\tInsert_Datetime,\n\t\tUpdate_Datetime,\n\t\tProcess_Name,\n\t\tPredicted_SE_Ex_Managers_Fees_Levys,\n\t\tPredicted_SE_Cartage,\n\t\tPredicted_SE_Harvesting,\n\t\tPredicted_SE_Roading_Capex_Maintanence,\n\t\tPredicted_SE_Other,\n\t\tActual_SE_Managers_Fees_Levys,\n\t\tActual_SE_Cartage,\n\t\tActual_SE_Harvesting,\n\t\tActual_SE_Roading_Capex_Maintanence,\n\t\tActual_SE_Other\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectedColumnsOutputInsert\nSegregateValidInvalidRows@InvalidRows derive(ConcatenatedMessage = concat(OperationTypeValidateMsg,SpeciesTypeValidateMsg,PredictedHarvestedGmtValidateMssg,ActualHarvestedGmtValidateMsg,ActualHarvestCommencementValidateMsg,AssetReportingDateValidateMsg)) ~> ConcatenateInvalidColumnsMessage\nConcatenateInvalidColumnsMessage select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tHarvest_Unit,\n\t\tOperation_Type = Harvest_Operation_Type,\n\t\tProduct,\n\t\tSpecies,\n\t\tTotal_Net_Stocked_Area_of_Harvest_Unit,\n\t\tPredicted_Harvested_GMT,\n\t\tPredicted_Revenue,\n\t\tPredicted_Stumpage,\n\t\tActual_Harvest_Commencement,\n\t\tActual_Date_of_Reconciliation,\n\t\tActual_Harvested_Net_Stocked_Area,\n\t\tActual_Harvested_GMT,\n\t\tActual_Revenue,\n\t\tInsert_Datetime,\n\t\tUpdate_Datetime,\n\t\tSource_File = Work_Book,\n\t\tSource_Sub_File = Work_Sheet,\n\t\tProcess_Name,\n\t\tPredicted_SE_Ex_Managers_Fees_Levys,\n\t\tPredicted_SE_Cartage,\n\t\tPredicted_SE_Harvesting,\n\t\tPredicted_SE_Roading_Capex_Maintanence,\n\t\tPredicted_SE_Other,\n\t\tActual_SE_Managers_Fees_Levys,\n\t\tActual_SE_Cartage,\n\t\tActual_SE_Harvesting,\n\t\tActual_SE_Roading_Capex_Maintanence,\n\t\tActual_SE_Other,\n\t\tError_Desc = ConcatenatedMessage\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectedOutputColumnsError\nDateTypeTransform keyGenerate(output(RowNumber as long),\n\tstartAt: 1L,\n\tstepValue: 1L,\n\tpartitionBy('hash', 1)) ~> GenerateRowNumber\nGenerateRowNumber filter(RowNumber > 1 && \r\n(not(isNull(Harvest_Unit)) || not(isNull(Harvest_Operation_Type)) || not(isNull(Product)) || \r\nnot(isNull(Species)) || not(isNull(Total_Net_Stocked_Area_of_Harvest_Unit)) || not(isNull(Actual_Harvest_Commencement)) || \r\nnot(isNull(Predicted_Harvested_GMT)) || not(isNull(Predicted_Revenue)) || not(isNull(Predicted_Sales_Expense_Fees_Levies_etc)) || not(isNull(Predicted_Sales_Expense_Cartage)) || \r\nnot(isNull(Predicted_Sales_Expense_Harvesting)) || not(isNull(Predicted_Sales_Expense_Roading_Capex_Maintenance)) || not(isNull(Predicted_Sales_Expense_Other)) || \r\nnot(isNull(Actual_Date_of_Reconciliation)) || not(isNull(Actual_Revenue)) || not(isNull(Actual_Harvested_GMT)) || not(isNull(Actual_Harvested_Net_Stocked_Area)) || \r\nnot(isNull(Actual_Sales_Expense_Managers_Fees_Levies)) || not(isNull(Actual_Sales_Expense_Cartage)) || not(isNull(Actual_Sales_Expense_Harvesting)) || \r\nnot(isNull(Actual_Sales_Expense_Roading_Capex_Maintenance)) || not(isNull(Actual_Sales_Expense_Other))\r\n)) ~> ExcludeFirstRow\nSourceDataTab derive(Insert_Datetime = fromUTC(currentUTC(), 'Australia/Sydney'),\n\t\tUpdate_Datetime = toTimestamp('9999-12-31 00:00:00'),\n\t\tWork_Book = $WorkbookName,\n\t\tWork_Sheet = $TabName,\n\t\tProcess_Name = concatWS('-',$MasterPipeline,$WorkbookName,$TabName),\n\t\tCurrentReportingPeriod = toDate($CurrentQuarterDate),\n\t\tReporting_Period = toDate(Reporting_Period),\n\t\tTotal_Net_Stocked_Area_of_Harvest_Unit = toDecimal(Total_Net_Stocked_Area_of_Harvest_Unit, 19, 4),\n\t\tPredicted_Harvested_GMT_toDecimal = toDecimal(Predicted_Harvested_GMT, 19, 4),\n\t\tPredicted_Revenue = toDecimal(Predicted_Revenue, 19, 4),\n\t\tPredicted_Stumpage = toDecimal(Predicted_Stumpage, 19, 4),\n\t\tActual_Harvest_Commencement_toDate = toDate(Actual_Harvest_Commencement),\n\t\tActual_Date_of_Reconciliation = toDate(Actual_Date_of_Reconciliation),\n\t\tActual_Harvested_Net_Stocked_Area = toDecimal(Actual_Harvested_Net_Stocked_Area, 19, 4),\n\t\tActual_Harvested_GMT_toDecimal = toDecimal(Actual_Harvested_GMT, 19, 4),\n\t\tActual_Revenue = toDecimal(Actual_Revenue, 19, 4),\n\t\tPredicted_SE_Ex_Managers_Fees_Levys = toDecimal(Actual_Sales_Expense_Managers_Fees_Levies, 19, 4),\n\t\tPredicted_SE_Cartage = toDecimal(Predicted_Sales_Expense_Cartage, 19, 4),\n\t\tPredicted_SE_Harvesting = toDecimal(Predicted_Sales_Expense_Harvesting, 19, 4),\n\t\tPredicted_SE_Roading_Capex_Maintanence = toDecimal(Predicted_Sales_Expense_Roading_Capex_Maintenance, 19, 4),\n\t\tPredicted_SE_Other = toDecimal(Predicted_Sales_Expense_Other, 19, 4),\n\t\tActual_SE_Managers_Fees_Levys = toDecimal(Actual_Sales_Expense_Managers_Fees_Levies, 19, 4),\n\t\tActual_SE_Cartage = toDecimal(Actual_Sales_Expense_Cartage, 19, 4),\n\t\tActual_SE_Harvesting = toDecimal(Actual_Sales_Expense_Harvesting, 19, 4),\n\t\tActual_SE_Roading_Capex_Maintanence = toDecimal(Actual_Sales_Expense_Roading_Capex_Maintenance, 19, 4),\n\t\tActual_SE_Other = toDecimal(Actual_Sales_Expense_Other, 19, 4)) ~> DateTypeTransform\nRelationalOperationType select(mapColumn(\n\t\tOperation_Type_Code_Lkp = Operation_Type_Code,\n\t\tOperation_Type_Lkp = Operation_Type\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectOperationTypeLkp\nExcludeFirstRow, SelectOperationTypeLkp lookup(Harvest_Operation_Type == Operation_Type_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupOperationType\nRelationalSpeciesType select(mapColumn(\n\t\tSpecies_Code_Lkp = Species_Code,\n\t\tSpecies_Lkp = Species\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectSpeciesTypeLkp\nLookupOperationType, SelectSpeciesTypeLkp lookup(Species == Species_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupSpeciesType\nSelectedColumnsOutputInsert sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tformat: 'parquet',\n\tpartitionFileNames:[(concatWS(\"_\", $WorkbookName, $TabName,$CurrentQuarterDate,'LoadReady'))],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tHarvest_Unit,\n\t\tOperation_Type_Code,\n\t\tProduct_Code,\n\t\tSpecies_Code,\n\t\tTotal_Net_Stocked_Area_of_Harvest_Unit,\n\t\tPredicted_Harvested_GMT,\n\t\tPredicted_Revenue,\n\t\tPredicted_Stumpage,\n\t\tActual_Harvest_Commencement,\n\t\tActual_Date_of_Reconcilation,\n\t\tActual_Harvested_Net_Stocked_Area,\n\t\tActual_Harvested_GMT,\n\t\tActual_Revenue,\n\t\tInsert_Datetime,\n\t\tUpdate_Datetime,\n\t\tProcess_Name,\n\t\tPredicted_SE_Ex_Managers_Fees_Levys,\n\t\tPredicted_SE_Cartage,\n\t\tPredicted_SE_Harvesting,\n\t\tPredicted_SE_Roading_Capex_Maintanence,\n\t\tPredicted_SE_Other,\n\t\tActual_SE_Managers_Fees_Levys,\n\t\tActual_SE_Cartage,\n\t\tActual_SE_Harvesting,\n\t\tActual_SE_Roading_Capex_Maintanence,\n\t\tActual_SE_Other\n\t),\n\tpartitionBy('hash', 1)) ~> TargetPersistentParquetInsert\nSelectedOutputColumnsError sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tHarvest_Unit,\n\t\tOperation_Type,\n\t\tProduct,\n\t\tSpecies,\n\t\tTotal_Net_Stocked_Area_of_Harvest_Unit,\n\t\tPredicted_Harvested_GMT,\n\t\tPredicted_Revenue,\n\t\tPredicted_Stumpage,\n\t\tActual_Harvest_Commencement,\n\t\tActual_Date_of_Reconciliation,\n\t\tActual_Harvested_Net_Stocked_Area,\n\t\tActual_Harvested_GMT,\n\t\tActual_Revenue,\n\t\tInsert_Datetime,\n\t\tUpdate_Datetime,\n\t\tSource_File,\n\t\tSource_Sub_File,\n\t\tProcess_Name,\n\t\tPredicted_SE_Ex_Managers_Fees_Levys,\n\t\tPredicted_SE_Cartage,\n\t\tPredicted_SE_Harvesting,\n\t\tPredicted_SE_Roading_Capex_Maintanence,\n\t\tPredicted_SE_Other,\n\t\tActual_SE_Managers_Fees_Levys,\n\t\tActual_SE_Cartage,\n\t\tActual_SE_Harvesting,\n\t\tActual_SE_Roading_Capex_Maintanence,\n\t\tActual_SE_Other,\n\t\tError_Desc\n\t)) ~> ErrorTable"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadXlsxHarvestReconcilliation_Step2_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ParquetPersistentOpsWithTabParam_ds",
								"type": "DatasetReference"
							},
							"name": "SourceReadyLoad"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "TargetRelational"
						}
					],
					"transformations": [
						{
							"name": "SelectKeyColumnsForDelete"
						},
						{
							"name": "AggregateAssetFundReportingPeriod"
						},
						{
							"name": "AlterRowDelete"
						}
					],
					"script": "parameters{\n\tWorkbookName as string,\n\tTabName as string\n}\nsource(output(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tReporting_Period as date,\n\t\tHarvest_Unit as string,\n\t\tOperation_Type_Code as string,\n\t\tProduct_Code as string,\n\t\tSpecies_Code as string,\n\t\tTotal_Net_Stocked_Area_of_Harvest_Unit as decimal(19,4),\n\t\tPredicted_Harvested_GMT as decimal(19,4),\n\t\tPredicted_Revenue as decimal(19,4),\n\t\tPredicted_Stumpage as decimal(19,4),\n\t\tActual_Harvest_Commencement as date,\n\t\tActual_Date_of_Reconcilation as date,\n\t\tActual_Harvested_Net_Stocked_Area as decimal(19,4),\n\t\tActual_Harvested_GMT as decimal(19,4),\n\t\tActual_Revenue as decimal(19,4),\n\t\tInsert_Datetime as timestamp,\n\t\tUpdate_Datetime as timestamp,\n\t\tProcess_Name as string,\n\t\tPredicted_SE_Ex_Managers_Fees_Levys as decimal(19,4),\n\t\tPredicted_SE_Cartage as decimal(19,4),\n\t\tPredicted_SE_Harvesting as decimal(19,4),\n\t\tPredicted_SE_Roading_Capex_Maintanence as decimal(19,4),\n\t\tPredicted_SE_Other as decimal(19,4),\n\t\tActual_SE_Managers_Fees_Levys as decimal(19,4),\n\t\tActual_SE_Cartage as decimal(19,4),\n\t\tActual_SE_Harvesting as decimal(19,4),\n\t\tActual_SE_Roading_Capex_Maintanence as decimal(19,4),\n\t\tActual_SE_Other as decimal(19,4)\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\tformat: 'parquet',\n\tpartitionBy('hash', 1)) ~> SourceReadyLoad\nSourceReadyLoad select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectKeyColumnsForDelete\nSelectKeyColumnsForDelete aggregate(groupBy(Asset_ID,\n\t\tFund_ID,\n\t\tReporting_Period),\n\tUniqueCount = count()) ~> AggregateAssetFundReportingPeriod\nAggregateAssetFundReportingPeriod alterRow(deleteIf(UniqueCount>0)) ~> AlterRowDelete\nAlterRowDelete sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:true,\n\tinsertable:false,\n\tupdateable:false,\n\tupsertable:false,\n\tkeys:['Asset_ID','Fund_ID','Reporting_Period'],\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period\n\t),\n\tpartitionBy('hash', 1)) ~> TargetRelational"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadXlsxHarvestReconcilliation_Step3_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ParquetPersistentOpsWithTabParam_ds",
								"type": "DatasetReference"
							},
							"name": "SourceReadyLoad"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "TargetRelational"
						}
					],
					"transformations": [
						{
							"name": "MapColumns"
						}
					],
					"script": "parameters{\n\tWorkbookName as string,\n\tTabName as string\n}\nsource(output(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tReporting_Period as date,\n\t\tHarvest_Unit as string,\n\t\tOperation_Type_Code as string,\n\t\tProduct_Code as string,\n\t\tSpecies_Code as string,\n\t\tTotal_Net_Stocked_Area_of_Harvest_Unit as decimal(19,4),\n\t\tPredicted_Harvested_GMT as decimal(19,4),\n\t\tPredicted_Revenue as decimal(19,4),\n\t\tPredicted_Stumpage as decimal(19,4),\n\t\tActual_Harvest_Commencement as date,\n\t\tActual_Date_of_Reconcilation as date,\n\t\tActual_Harvested_Net_Stocked_Area as decimal(19,4),\n\t\tActual_Harvested_GMT as decimal(19,4),\n\t\tActual_Revenue as decimal(19,4),\n\t\tInsert_Datetime as timestamp,\n\t\tUpdate_Datetime as timestamp,\n\t\tProcess_Name as string,\n\t\tPredicted_SE_Ex_Managers_Fees_Levys as decimal(19,4),\n\t\tPredicted_SE_Cartage as decimal(19,4),\n\t\tPredicted_SE_Harvesting as decimal(19,4),\n\t\tPredicted_SE_Roading_Capex_Maintanence as decimal(19,4),\n\t\tPredicted_SE_Other as decimal(19,4),\n\t\tActual_SE_Managers_Fees_Levys as decimal(19,4),\n\t\tActual_SE_Cartage as decimal(19,4),\n\t\tActual_SE_Harvesting as decimal(19,4),\n\t\tActual_SE_Roading_Capex_Maintanence as decimal(19,4),\n\t\tActual_SE_Other as decimal(19,4)\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\tformat: 'parquet',\n\tpartitionBy('hash', 1)) ~> SourceReadyLoad\nSourceReadyLoad select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tHarvest_Unit,\n\t\tOperation_Type_Code,\n\t\tProduct_Code,\n\t\tSpecies_Code,\n\t\tTotal_Net_Stocked_Area_of_Harvest_Unit,\n\t\tPredicted_Harvested_GMT,\n\t\tPredicted_Revenue,\n\t\tPredicted_Stumpage,\n\t\tActual_Harvest_Commencement,\n\t\tActual_Date_of_Reconcilation,\n\t\tActual_Harvested_Net_Stocked_Area,\n\t\tActual_Harvested_GMT,\n\t\tActual_Revenue,\n\t\tInsert_Datetime,\n\t\tUpdate_Datetime,\n\t\tProcess_Name,\n\t\tPredicted_SE_Ex_Managers_Fees_Levys,\n\t\tPredicted_SE_Cartage,\n\t\tPredicted_SE_Harvesting,\n\t\tPredicted_SE_Roading_Capex_Maintanence,\n\t\tPredicted_SE_Other,\n\t\tActual_SE_Managers_Fees_Levys,\n\t\tActual_SE_Cartage,\n\t\tActual_SE_Harvesting,\n\t\tActual_SE_Roading_Capex_Maintanence,\n\t\tActual_SE_Other\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> MapColumns\nMapColumns sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tHarvest_Unit,\n\t\tOperation_Type_Code,\n\t\tProduct_Code,\n\t\tSpecies_Code,\n\t\tTotal_Net_Stocked_Area_of_Harvest_Unit,\n\t\tPredicted_Harvested_GMT,\n\t\tPredicted_Revenue,\n\t\tPredicted_Stumpage,\n\t\tActual_Harvest_Commencement,\n\t\tActual_Date_of_Reconcilation,\n\t\tActual_Harvested_Net_Stocked_Area,\n\t\tActual_Harvested_GMT,\n\t\tActual_Revenue,\n\t\tInsert_Datetime,\n\t\tUpdate_Datetime,\n\t\tProcess_Name,\n\t\tPredicted_SE_Ex_Managers_Fees_Levys,\n\t\tPredicted_SE_Cartage,\n\t\tPredicted_SE_Harvesting,\n\t\tPredicted_SE_Roading_Capex_Maintanence,\n\t\tPredicted_SE_Other,\n\t\tActual_SE_Managers_Fees_Levys,\n\t\tActual_SE_Cartage,\n\t\tActual_SE_Harvesting,\n\t\tActual_SE_Roading_Capex_Maintanence,\n\t\tActual_SE_Other\n\t),\n\tpartitionBy('hash', 1)) ~> TargetRelational"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadXlsxMajorSevereIncidents_Step1_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ParquetPersistentOpsWithTabParam_ds",
								"type": "DatasetReference"
							},
							"name": "SourceDataTab"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGeneric_ds",
								"type": "DatasetReference"
							},
							"name": "RelationalOpsIncidentType"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGeneric_ds",
								"type": "DatasetReference"
							},
							"name": "RelationalIncident"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ParquetPersistentOps_ds",
								"type": "DatasetReference"
							},
							"name": "TargetPersistentParquetInsert"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "ErrorTable"
						},
						{
							"dataset": {
								"referenceName": "ParquetPersistentOps_ds",
								"type": "DatasetReference"
							},
							"name": "TargetPersistenParquetUpdate"
						}
					],
					"transformations": [
						{
							"name": "ValidateMandatoryColumns",
							"description": "ReportingDateCertificationIDValidateMsg is a test and should be considered as part of the conditional split Insert/Update activity"
						},
						{
							"name": "SegregateValidInvalidRows"
						},
						{
							"name": "SelectedColumnsOutputInsert"
						},
						{
							"name": "ConcatenateInvalidColumnsMessage"
						},
						{
							"name": "SelectedOutputColumnsError"
						},
						{
							"name": "GenerateRowNumber"
						},
						{
							"name": "ExcludeFirstRow"
						},
						{
							"name": "DateTypeTransform"
						},
						{
							"name": "SelectIncidentTypeLkp"
						},
						{
							"name": "LookupIncidentType"
						},
						{
							"name": "SplitInsertAndUpdate",
							"description": "1. The condition assume that the records from the current reporting period are deleted first if any (asset id, fund id, current reporting period)\n2. Records where reporting period equal current reporting period (disregard certification id) are inserted/reinserted after delete in 1\n3. Remaining records are not from current reporting period and the certification ids must not be null. These are updated"
						},
						{
							"name": "SelectColumnsOutputUpdate"
						},
						{
							"name": "UpdateDatetimeValue"
						},
						{
							"name": "SelectIncidentLkp"
						},
						{
							"name": "LookupIncidents"
						}
					],
					"script": "parameters{\n\tMasterUtcTag as string (\"2020-08-28T06:05:53.4181322Z\"),\n\tCurrentRunDateTime as string (\"2020-08-01\"),\n\tWorkbookName as string (\"Wenita Forestry Products Q4 FY20 V2.xlsx\"),\n\tTabName as string (\"Major Severe Incidents\"),\n\tCurrentQuarterDate as string (\"2020-06-30\"),\n\tMasterPipeline as string\n}\nsource(output(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tReporting_Period as string,\n\t\tIncident_Id as string,\n\t\tValidation_Flag as string,\n\t\tIncident_Type as string,\n\t\tCategory as string,\n\t\tIncident_Severity as string,\n\t\tIncident_Description as string,\n\t\tInvestigation_Undertaken as string,\n\t\tIncident_Findings as string,\n\t\tIncident_Date as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\tformat: 'parquet',\n\tpartitionBy('hash', 1)) ~> SourceDataTab\nsource(output(\n\t\tIncident_Type_Code as string,\n\t\tIncident_Type as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT Incident_Type_Code\\n      ,Incident_Type\\n  FROM relational.OPS_Incident_Type\\n  WHERE Active_YN = \\'Y\\'',\n\tformat: 'query',\n\tpartitionBy('hash', 1)) ~> RelationalOpsIncidentType\nsource(output(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tReporting_Period as date,\n\t\tIncident_ID as integer\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT Asset_ID\\n      ,Fund_ID\\n      ,Reporting_Period\\n      ,Incident_ID\\n  FROM relational.OPS_Incident',\n\tformat: 'query') ~> RelationalIncident\nLookupIncidentType derive(Incident_Type_Validate_Msg = iif(isNull(Incident_Type_Code_Lkp), \"Incident Type Lookup Error/\", \"\"),\n\t\tIncident_Date_Validate_Msg = iif(isNull(Incident_Date), \"Blank Incident Date/\", \"\"),\n\t\tIncident_Severity_Validate_Msg = iif(isNull(Incident_Severity), \"Blank Incident Severity/\", \"\"),\n\t\tAssetReportingDateValidateMsg = iif(isNull(Asset_ID) || isNull(Fund_ID) || isNull(Reporting_Period), \"Invalid Asset or Reporting Period/\", \"\"),\n\t\tReportingDateIncidentIDValidateMsg = iif(iif(CurrentReportingPeriod != Reporting_Period, true(), false()) && isNull(Incident_Id),\"Null Incident ID for non-current Reporting Period/\",\"\"),\n\t\tLkpRelationalIncidentIDValidateMsg = iif(not(isNull(Incident_ID_Lkp)),iif(equals(concat(Asset_ID_Lkp,Fund_ID_Lkp), concat(Asset_ID,Fund_ID)),\"\",\"Incident ID does not belong to Asset/\"),\"\")) ~> ValidateMandatoryColumns\nValidateMandatoryColumns split(length(concatWS('',Incident_Type_Validate_Msg,Incident_Date_Validate_Msg,Incident_Severity_Validate_Msg,AssetReportingDateValidateMsg,LkpRelationalIncidentIDValidateMsg,ReportingDateIncidentIDValidateMsg)) == 0,\n\tdisjoint: false) ~> SegregateValidInvalidRows@(ValidRows, InvalidRows)\nSplitInsertAndUpdate@Insert select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tIncident_Id,\n\t\tIncident_Type_Code = Incident_Type_Code_Lkp,\n\t\tIncident_Severity,\n\t\tIncident_Description,\n\t\tInvestigation_Undertaken,\n\t\tIncident_Findings,\n\t\tIncident_Date,\n\t\tInsert_Datetime,\n\t\tUpdate_Datetime,\n\t\tWork_Book,\n\t\tWork_Sheet,\n\t\tProcess_Name\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectedColumnsOutputInsert\nSegregateValidInvalidRows@InvalidRows derive(ConcatenatedMessage = concat(Incident_Type_Validate_Msg, Incident_Date_Validate_Msg,Incident_Severity_Validate_Msg,AssetReportingDateValidateMsg,ReportingDateIncidentIDValidateMsg,LkpRelationalIncidentIDValidateMsg)) ~> ConcatenateInvalidColumnsMessage\nConcatenateInvalidColumnsMessage select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tIncident_Id,\n\t\tIncident_Type,\n\t\tIncident_Severity,\n\t\tIncident_Description,\n\t\tInvestigation_Undertaken,\n\t\tIncident_Findings,\n\t\tIncident_Date,\n\t\tInsert_Datetime,\n\t\tSource_File = Work_Book,\n\t\tSource_Sub_File = Work_Sheet,\n\t\tProcess_Name,\n\t\tError_Desc = ConcatenatedMessage\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectedOutputColumnsError\nDateTypeTransform keyGenerate(output(RowNumber as long),\n\tstartAt: 1L,\n\tstepValue: 1L,\n\tpartitionBy('hash', 1)) ~> GenerateRowNumber\nGenerateRowNumber filter(RowNumber > 1 &&\r\n(not(isNull(Incident_Id)) || not(isNull(Incident_Type)) || not(isNull(Incident_Severity)) ||\r\nnot(isNull(Incident_Description)) || not(isNull(Investigation_Undertaken)) || not(isNull(Incident_Findings)) || not(isNull(Incident_Date))\r\n)) ~> ExcludeFirstRow\nSourceDataTab derive(Incident_Id = toInteger(Incident_Id),\n\t\tReporting_Period = toDate(Reporting_Period),\n\t\tIncident_Date = toDate(Incident_Date),\n\t\tInsert_Datetime = fromUTC(currentUTC(), 'Australia/Sydney'),\n\t\tUpdate_Datetime = toTimestamp('9999-12-31 00:00:00'),\n\t\tWork_Book = $WorkbookName,\n\t\tWork_Sheet = $TabName,\n\t\tProcess_Name = concatWS('-',$MasterPipeline,$WorkbookName,$TabName),\n\t\tCurrentReportingPeriod = toDate($CurrentQuarterDate)) ~> DateTypeTransform\nRelationalOpsIncidentType select(mapColumn(\n\t\tIncident_Type_Code_Lkp = Incident_Type_Code,\n\t\tIncident_Type_Lkp = Incident_Type\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectIncidentTypeLkp\nLookupIncidents, SelectIncidentTypeLkp lookup(Incident_Type == Incident_Type_Lkp,\n\tmultiple: false,\n\tpickup: 'first',\n\tasc(Incident_Type_Code_Lkp, false),\n\tbroadcast: 'auto')~> LookupIncidentType\nSegregateValidInvalidRows@ValidRows split(equals(Reporting_Period, CurrentReportingPeriod),\n\tdisjoint: false) ~> SplitInsertAndUpdate@(Insert, Update)\nUpdateDatetimeValue select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tIncident_Id,\n\t\tIncident_Type_Code = Incident_Type_Code_Lkp,\n\t\tIncident_Severity,\n\t\tIncident_Description,\n\t\tInvestigation_Undertaken,\n\t\tIncident_Findings,\n\t\tIncident_Date,\n\t\tInsert_Datetime,\n\t\tUpdate_Datetime,\n\t\tWork_Book,\n\t\tWork_Sheet,\n\t\tProcess_Name\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectColumnsOutputUpdate\nSplitInsertAndUpdate@Update derive(Update_Datetime = fromUTC(currentUTC(), 'Australia/Sydney')) ~> UpdateDatetimeValue\nRelationalIncident select(mapColumn(\n\t\tAsset_ID_Lkp = Asset_ID,\n\t\tFund_ID_Lkp = Fund_ID,\n\t\tReporting_Period_Lkp = Reporting_Period,\n\t\tIncident_ID_Lkp = Incident_ID\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectIncidentLkp\nExcludeFirstRow, SelectIncidentLkp lookup(Incident_Id == Incident_ID_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupIncidents\nSelectedColumnsOutputInsert sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tformat: 'parquet',\n\tpartitionFileNames:[(concatWS(\"_\", $WorkbookName, $TabName,$CurrentQuarterDate,'LoadReady'))],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tIncident_Id,\n\t\tIncident_Type_Code,\n\t\tIncident_Severity,\n\t\tIncident_Description,\n\t\tInvestigation_Undertaken,\n\t\tIncident_Findings,\n\t\tIncident_Date,\n\t\tInsert_Datetime,\n\t\tUpdate_Datetime,\n\t\tWork_Book,\n\t\tWork_Sheet,\n\t\tProcess_Name\n\t),\n\tpartitionBy('hash', 1)) ~> TargetPersistentParquetInsert\nSelectedOutputColumnsError sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tIncident_Id,\n\t\tIncident_Type,\n\t\tIncident_Severity,\n\t\tIncident_Description,\n\t\tInvestigation_Undertaken,\n\t\tIncident_Findings,\n\t\tIncident_Date,\n\t\tInsert_Datetime,\n\t\tSource_File,\n\t\tSource_Sub_File,\n\t\tProcess_Name,\n\t\tError_Desc\n\t),\n\tpartitionBy('hash', 1)) ~> ErrorTable\nSelectColumnsOutputUpdate sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tformat: 'parquet',\n\tpartitionFileNames:[(concatWS(\"_\", $WorkbookName, $TabName,$CurrentQuarterDate,'Update'))],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tIncident_Id,\n\t\tIncident_Type_Code,\n\t\tIncident_Severity,\n\t\tIncident_Description,\n\t\tInvestigation_Undertaken,\n\t\tIncident_Findings,\n\t\tIncident_Date,\n\t\tInsert_Datetime,\n\t\tUpdate_Datetime,\n\t\tWork_Book,\n\t\tWork_Sheet,\n\t\tProcess_Name\n\t),\n\tpartitionBy('hash', 1)) ~> TargetPersistenParquetUpdate"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadXlsxMajorSevereIncidents_Step2_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ParquetPersistentOpsWithTabParam_ds",
								"type": "DatasetReference"
							},
							"name": "SourceReadyLoad"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "TargetRelationalDelete"
						}
					],
					"transformations": [
						{
							"name": "SelectColumnsForDelete"
						},
						{
							"name": "AggregateAssetFundReportingPeriod"
						},
						{
							"name": "AlterRowDelete"
						}
					],
					"script": "parameters{\n\tWorkbookName as string,\n\tTabName as string\n}\nsource(output(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tReporting_Period as date,\n\t\tIncident_Id as integer,\n\t\tIncident_Type as string,\n\t\tIncident_Severity as string,\n\t\tIncident_Description as string,\n\t\tInvestigation_Undertaken as string,\n\t\tIncident_Findings as string,\n\t\tIncident_Date as date,\n\t\tInsert_Datetime as timestamp,\n\t\tUpdate_Datetime as timestamp,\n\t\tWork_Book as string,\n\t\tWork_Sheet as string,\n\t\tProcess_Name as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\tformat: 'parquet',\n\tpartitionBy('hash', 1)) ~> SourceReadyLoad\nSourceReadyLoad select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectColumnsForDelete\nSelectColumnsForDelete aggregate(groupBy(Asset_ID,\n\t\tFund_ID,\n\t\tReporting_Period),\n\tUniqueCount = count()) ~> AggregateAssetFundReportingPeriod\nAggregateAssetFundReportingPeriod alterRow(deleteIf(UniqueCount>0)) ~> AlterRowDelete\nAlterRowDelete sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:true,\n\tinsertable:false,\n\tupdateable:false,\n\tupsertable:false,\n\tkeys:['Asset_ID','Fund_ID','Reporting_Period'],\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period\n\t),\n\tpartitionBy('hash', 1)) ~> TargetRelationalDelete"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadXlsxMajorSevereIncidents_Step3_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ParquetPersistentOpsWithTabParam_ds",
								"type": "DatasetReference"
							},
							"name": "SourceReadyLoad"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "TargetRelational"
						}
					],
					"transformations": [
						{
							"name": "MapColumns"
						}
					],
					"script": "parameters{\n\tWorkbookName as string,\n\tTabName as string\n}\nsource(output(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tReporting_Period as date,\n\t\tIncident_Id as integer,\n\t\tIncident_Type_Code as string,\n\t\tIncident_Severity as string,\n\t\tIncident_Description as string,\n\t\tInvestigation_Undertaken as string,\n\t\tIncident_Findings as string,\n\t\tIncident_Date as date,\n\t\tInsert_Datetime as timestamp,\n\t\tUpdate_Datetime as timestamp,\n\t\tWork_Book as string,\n\t\tWork_Sheet as string,\n\t\tProcess_Name as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\tformat: 'parquet',\n\tpartitionBy('hash', 1)) ~> SourceReadyLoad\nSourceReadyLoad select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tIncident_Id,\n\t\tIncident_Type_Code,\n\t\tIncident_Severity,\n\t\tIncident_Description,\n\t\tInvestigation_Undertaken,\n\t\tIncident_Findings,\n\t\tIncident_Date,\n\t\tInsert_Datetime,\n\t\tUpdate_Datetime,\n\t\tWork_Book,\n\t\tWork_Sheet,\n\t\tProcess_Name\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> MapColumns\nMapColumns sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tIncident_Type_Code,\n\t\tIncident_Severity,\n\t\tIncident_Description,\n\t\tInvestigation_Undertaken,\n\t\tIncident_Findings,\n\t\tIncident_Date,\n\t\tInsert_Datetime,\n\t\tUpdate_Datetime,\n\t\tWork_Book,\n\t\tWork_Sheet,\n\t\tProcess_Name\n\t),\n\tpartitionBy('hash', 1)) ~> TargetRelational"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadXlsxMajorSevereIncidents_Step4_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ParquetPersistentOpsWithTabParam_ds",
								"type": "DatasetReference"
							},
							"name": "SourceUpdate"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "TargetRelational"
						}
					],
					"transformations": [
						{
							"name": "MapColumns"
						},
						{
							"name": "AlterRowUpdate"
						}
					],
					"script": "parameters{\n\tWorkbookName as string,\n\tTabName as string\n}\nsource(output(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tReporting_Period as date,\n\t\tIncident_Id as integer,\n\t\tIncident_Type_Code as string,\n\t\tIncident_Severity as string,\n\t\tIncident_Description as string,\n\t\tInvestigation_Undertaken as string,\n\t\tIncident_Findings as string,\n\t\tIncident_Date as date,\n\t\tInsert_Datetime as timestamp,\n\t\tUpdate_Datetime as timestamp,\n\t\tWork_Book as string,\n\t\tWork_Sheet as string,\n\t\tProcess_Name as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\tformat: 'parquet',\n\tpartitionBy('hash', 1)) ~> SourceUpdate\nSourceUpdate select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tIncident_Id,\n\t\tIncident_Type_Code,\n\t\tIncident_Severity,\n\t\tIncident_Description,\n\t\tInvestigation_Undertaken,\n\t\tIncident_Findings,\n\t\tIncident_Date,\n\t\tInsert_Datetime,\n\t\tUpdate_Datetime,\n\t\tWork_Book,\n\t\tWork_Sheet,\n\t\tProcess_Name\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> MapColumns\nMapColumns alterRow(updateIf(not(isNull(Incident_Id)))) ~> AlterRowUpdate\nAlterRowUpdate sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['Incident_Id'],\n\tskipKeyWrites:true,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tIncident_Id,\n\t\tIncident_Type_Code,\n\t\tIncident_Severity,\n\t\tIncident_Description,\n\t\tInvestigation_Undertaken,\n\t\tIncident_Findings,\n\t\tIncident_Date,\n\t\tInsert_Datetime,\n\t\tUpdate_Datetime,\n\t\tProcess_Name\n\t),\n\tpartitionBy('hash', 1)) ~> TargetRelational"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadXlsxOperations_Step1_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ParquetPersistentOpsWithTabParam_ds",
								"type": "DatasetReference"
							},
							"name": "SourceDataTab"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGeneric_ds",
								"type": "DatasetReference"
							},
							"name": "RelationalOperationType"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGeneric_ds",
								"type": "DatasetReference"
							},
							"name": "RelationalSpeciesType"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ParquetPersistentOps_ds",
								"type": "DatasetReference"
							},
							"name": "TargetPersistentParquetInsert"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "ErrorTable"
						}
					],
					"transformations": [
						{
							"name": "ValidateMandatoryColumns",
							"description": "ReportingDateCertificationIDValidateMsg is a test and should be considered as part of the conditional split Insert/Update activity"
						},
						{
							"name": "SegregateValidInvalidRows"
						},
						{
							"name": "SelectedColumnsOutputInsert"
						},
						{
							"name": "ConcatenateInvalidColumnsMessage"
						},
						{
							"name": "SelectedOutputColumnsError"
						},
						{
							"name": "GenerateRowNumber"
						},
						{
							"name": "ExcludeFirstRow"
						},
						{
							"name": "DateTypeTransform"
						},
						{
							"name": "SelectOperationTypeLkp"
						},
						{
							"name": "LookupOperationType"
						},
						{
							"name": "SelectSpeciesTypeLkp"
						},
						{
							"name": "LookupSpeciesType"
						}
					],
					"script": "parameters{\n\tMasterUtcTag as string,\n\tCurrentRunDateTime as string,\n\tWorkbookName as string,\n\tTabName as string,\n\tCurrentQuarterDate as string,\n\tMasterPipeline as string\n}\nsource(output(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tReporting_Period as string,\n\t\tValidation_Flag as string,\n\t\tOperation_Type as string,\n\t\tArea_Treated as string,\n\t\tCost_of_Treatment as string,\n\t\tAverage_Unit_Cost as string,\n\t\tBudget_Area_Treated as string,\n\t\tBudget_Treatment_Cost as string,\n\t\tBudget_Unit_Cost as string,\n\t\tvariation_Area_Treated as string,\n\t\tvariation_Treatment_Cost as string,\n\t\tvariation_Unit_Cost as string,\n\t\tDate_Last_Age_Class_Established as string,\n\t\tSpecies_Survived as string,\n\t\tSurvival_rate_of_last_age_class_established as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\tformat: 'parquet',\n\tpartitionBy('hash', 1)) ~> SourceDataTab\nsource(output(\n\t\tOperation_Type_Code as string,\n\t\tOperation_Type as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT DISTINCT [Operation_Type_Code]\\n      ,[Operation_Type]\\n  FROM [relational].[OPS_Operation_Type]\\nWHERE [Active_YN] = \\'Y\\'',\n\tformat: 'query',\n\tpartitionBy('hash', 1)) ~> RelationalOperationType\nsource(output(\n\t\tSpecies_Code as string,\n\t\tSpecies as string,\n\t\tSpecies_Group as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT DISTINCT [Species_Code]\\n      ,[Species]\\n      ,[Species_Group]\\nFROM [relational].[OPS_Species_Type]\\nWHERE Active_YN = \\'Y\\'',\n\tformat: 'query') ~> RelationalSpeciesType\nLookupSpeciesType derive(OperationTypeValidateMsg = iif(isNull(Operation_Type_Code_Lkp), \"Operation Type/\", \"\"),\n\t\tAreaTreatedValidateMsg = iif(not(isNull(Area_Treated)),iif(not(isNull(Area_Treated_toDecimal)),\"\",\"Area Treated/\"),\"Area Treated/\"),\n\t\tAssetReportingDateValidateMsg = iif(isNull(Asset_ID) || isNull(Fund_ID) || isNull(Reporting_Period), \"Invalid Asset or Reporting Period/\", \"\"),\n\t\tSpeciesSurvivedValidateMsg = iif(not(isNull(Species_Survived)), iif(not(isNull(Species_Code_Lkp)), \"\", \"Species Survived/\"), \"\")) ~> ValidateMandatoryColumns\nValidateMandatoryColumns split(length(concatWS('',OperationTypeValidateMsg, AreaTreatedValidateMsg,AssetReportingDateValidateMsg,SpeciesSurvivedValidateMsg)) == 0,\n\tdisjoint: false) ~> SegregateValidInvalidRows@(ValidRows, InvalidRows)\nSegregateValidInvalidRows@ValidRows select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tOperation_Type_Code = Operation_Type_Code_Lkp,\n\t\tArea_Treated = Area_Treated_toDecimal,\n\t\tTreatment_Cost = Cost_of_Treatment,\n\t\tUnit_Cost = Average_Unit_Cost,\n\t\tBudget_Area_Treated,\n\t\tBudget_Treatment_Cost,\n\t\tBudget_Unit_Cost,\n\t\tLast_Age_Class_Date = Date_Last_Age_Class_Established,\n\t\tSpecies_Survived = Species_Code_Lkp,\n\t\tLast_Age_Class_Survival_Rate = Survival_rate_of_last_age_class_established,\n\t\tInsert_Datetime,\n\t\tUpdate_Datetime,\n\t\tProcess_Name\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectedColumnsOutputInsert\nSegregateValidInvalidRows@InvalidRows derive(ConcatenatedMessage = concat(OperationTypeValidateMsg,AreaTreatedValidateMsg,AssetReportingDateValidateMsg,SpeciesSurvivedValidateMsg)) ~> ConcatenateInvalidColumnsMessage\nConcatenateInvalidColumnsMessage select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tOperation_Type,\n\t\tArea_Treated,\n\t\tTreatment_Cost = Cost_of_Treatment,\n\t\tUnit_Cost = Average_Unit_Cost,\n\t\tBudget_Area_Treated,\n\t\tBudget_Treatment_Cost,\n\t\tBudget_Unit_Cost,\n\t\tLast_Age_Class_Date = Date_Last_Age_Class_Established,\n\t\tSpecies_Survived,\n\t\tLast_Age_Class_Survival_Rate = Survival_rate_of_last_age_class_established,\n\t\tInsert_Datetime,\n\t\tSource_File = Work_Book,\n\t\tSource_Sub_File = Work_Sheet,\n\t\tProcess_Name,\n\t\tError_Desc = ConcatenatedMessage\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectedOutputColumnsError\nDateTypeTransform keyGenerate(output(RowNumber as long),\n\tstartAt: 1L,\n\tstepValue: 1L,\n\tpartitionBy('hash', 1)) ~> GenerateRowNumber\nGenerateRowNumber filter(RowNumber > 1 && \r\n(not(isNull(Operation_Type)) || not(isNull(Area_Treated)) || not(isNull(Cost_of_Treatment)) || \r\nnot(isNull(Budget_Area_Treated)) || not(isNull(Budget_Treatment_Cost)) || \r\nnot(isNull(Date_Last_Age_Class_Established)) || not(isNull(Species_Survived)) || not(isNull(Survival_rate_of_last_age_class_established))\r\n)) ~> ExcludeFirstRow\nSourceDataTab derive(Insert_Datetime = fromUTC(currentUTC(), 'Australia/Sydney'),\n\t\tUpdate_Datetime = toTimestamp('9999-12-31 00:00:00'),\n\t\tWork_Book = $WorkbookName,\n\t\tWork_Sheet = $TabName,\n\t\tProcess_Name = concatWS('-',$MasterPipeline,$WorkbookName,$TabName),\n\t\tCurrentReportingPeriod = toDate($CurrentQuarterDate),\n\t\tReporting_Period = toDate(Reporting_Period),\n\t\tArea_Treated_toDecimal = toDecimal(Area_Treated, 19, 4),\n\t\tCost_of_Treatment = toDecimal(Cost_of_Treatment, 19, 4),\n\t\tAverage_Unit_Cost = toDecimal(Average_Unit_Cost, 19, 4),\n\t\tDate_Last_Age_Class_Established = toDate(Date_Last_Age_Class_Established),\n\t\tSurvival_rate_of_last_age_class_established = toDecimal(Survival_rate_of_last_age_class_established, 5, 2),\n\t\tBudget_Area_Treated = toDecimal(Budget_Area_Treated, 19, 4),\n\t\tBudget_Treatment_Cost = toDecimal(Budget_Treatment_Cost, 19, 4),\n\t\tBudget_Unit_Cost = toDecimal(Budget_Unit_Cost, 19, 4)) ~> DateTypeTransform\nRelationalOperationType select(mapColumn(\n\t\tOperation_Type_Code_Lkp = Operation_Type_Code,\n\t\tOperation_Type_Lkp = Operation_Type\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectOperationTypeLkp\nExcludeFirstRow, SelectOperationTypeLkp lookup(Operation_Type == Operation_Type_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupOperationType\nRelationalSpeciesType select(mapColumn(\n\t\tSpecies_Code_Lkp = Species_Code,\n\t\tSpecies_Lkp = Species,\n\t\tSpecies_Group_Lkp = Species_Group\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectSpeciesTypeLkp\nLookupOperationType, SelectSpeciesTypeLkp lookup(Species_Survived == Species_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupSpeciesType\nSelectedColumnsOutputInsert sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tformat: 'parquet',\n\tpartitionFileNames:[(concatWS(\"_\", $WorkbookName, $TabName,$CurrentQuarterDate,'LoadReady'))],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tOperation_Type_Code,\n\t\tArea_Treated,\n\t\tTreatment_Cost,\n\t\tUnit_Cost,\n\t\tBudget_Area_Treated,\n\t\tBudget_Treatment_Cost,\n\t\tBudget_Unit_Cost,\n\t\tLast_Age_Class_Date,\n\t\tSpecies_Survived,\n\t\tLast_Age_Class_Survival_Rate,\n\t\tInsert_Datetime,\n\t\tUpdate_Datetime,\n\t\tProcess_Name\n\t),\n\tpartitionBy('hash', 1)) ~> TargetPersistentParquetInsert\nSelectedOutputColumnsError sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tOperation_Type,\n\t\tArea_Treated,\n\t\tTreatment_Cost,\n\t\tUnit_Cost,\n\t\tBudget_Area_Treated,\n\t\tBudget_Treatment_Cost,\n\t\tBudget_Unit_Cost,\n\t\tLast_Age_Class_Date,\n\t\tSpecies_Survived,\n\t\tLast_Age_Class_Survival_Rate,\n\t\tInsert_Datetime,\n\t\tSource_File,\n\t\tSource_Sub_File,\n\t\tProcess_Name,\n\t\tError_Desc\n\t)) ~> ErrorTable"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadXlsxOperations_Step2_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ParquetPersistentOpsWithTabParam_ds",
								"type": "DatasetReference"
							},
							"name": "SourceReadyLoad"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "TargetRelational"
						}
					],
					"transformations": [
						{
							"name": "SelectKeyColumnsForDelete"
						},
						{
							"name": "AggregateAssetFundReportingPeriod"
						},
						{
							"name": "AlterRowDelete"
						}
					],
					"script": "parameters{\n\tWorkbookName as string,\n\tTabName as string\n}\nsource(output(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tReporting_Period as date,\n\t\tOperation_Type_Code as string,\n\t\tArea_Treated as decimal(19,4),\n\t\tTreatment_Cost as decimal(19,4),\n\t\tUnit_Cost as decimal(19,4),\n\t\tBudget_Area_Treated as decimal(19,4),\n\t\tBudget_Treatment_Cost as decimal(19,4),\n\t\tBudget_Unit_Cost as decimal(19,4),\n\t\tLast_Age_Class_Date as date,\n\t\tSpecies_Survived as string,\n\t\tLast_Age_Class_Survival_Rate as decimal(5,2),\n\t\tInsert_Datetime as timestamp,\n\t\tUpdate_Datetime as timestamp,\n\t\tProcess_Name as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\tformat: 'parquet',\n\tpartitionBy('hash', 1)) ~> SourceReadyLoad\nSourceReadyLoad select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectKeyColumnsForDelete\nSelectKeyColumnsForDelete aggregate(groupBy(Asset_ID,\n\t\tFund_ID,\n\t\tReporting_Period),\n\tUniqueCount = count()) ~> AggregateAssetFundReportingPeriod\nAggregateAssetFundReportingPeriod alterRow(deleteIf(UniqueCount>0)) ~> AlterRowDelete\nAlterRowDelete sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:true,\n\tinsertable:false,\n\tupdateable:false,\n\tupsertable:false,\n\tkeys:['Asset_ID','Fund_ID','Reporting_Period'],\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period\n\t),\n\tpartitionBy('hash', 1)) ~> TargetRelational"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadXlsxOperations_Step3_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ParquetPersistentOpsWithTabParam_ds",
								"type": "DatasetReference"
							},
							"name": "SourceReadyLoad"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "TargetRelational"
						}
					],
					"transformations": [
						{
							"name": "MapColumns"
						}
					],
					"script": "parameters{\n\tWorkbookName as string,\n\tTabName as string\n}\nsource(output(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tReporting_Period as date,\n\t\tOperation_Type_Code as string,\n\t\tArea_Treated as decimal(19,4),\n\t\tTreatment_Cost as decimal(19,4),\n\t\tUnit_Cost as decimal(19,4),\n\t\tBudget_Area_Treated as decimal(19,4),\n\t\tBudget_Treatment_Cost as decimal(19,4),\n\t\tBudget_Unit_Cost as decimal(19,4),\n\t\tLast_Age_Class_Date as date,\n\t\tSpecies_Survived as string,\n\t\tLast_Age_Class_Survival_Rate as decimal(5,2),\n\t\tInsert_Datetime as timestamp,\n\t\tUpdate_Datetime as timestamp,\n\t\tProcess_Name as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\tformat: 'parquet',\n\tpartitionBy('hash', 1)) ~> SourceReadyLoad\nSourceReadyLoad select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tOperation_Type_Code,\n\t\tArea_Treated,\n\t\tTreatment_Cost,\n\t\tUnit_Cost,\n\t\tBudget_Area_Treated,\n\t\tBudget_Treatment_Cost,\n\t\tBudget_Unit_Cost,\n\t\tLast_Age_Class_Date,\n\t\tSpecies_Survived,\n\t\tLast_Age_Class_Survival_Rate,\n\t\tInsert_Datetime,\n\t\tUpdate_Datetime,\n\t\tProcess_Name\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> MapColumns\nMapColumns sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tOperation_Type_Code,\n\t\tArea_Treated,\n\t\tTreatment_Cost,\n\t\tUnit_Cost,\n\t\tBudget_Area_Treated,\n\t\tBudget_Treatment_Cost,\n\t\tBudget_Unit_Cost,\n\t\tLast_Age_Class_Date,\n\t\tSpecies_Survived,\n\t\tLast_Age_Class_Survival_Rate,\n\t\tInsert_Datetime,\n\t\tUpdate_Datetime,\n\t\tProcess_Name\n\t),\n\tpartitionBy('hash', 1)) ~> TargetRelational"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadXlsxOtherSales_Step1_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ParquetPersistentOpsWithTabParam_ds",
								"type": "DatasetReference"
							},
							"name": "SourceDataTab"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ParquetPersistentOps_ds",
								"type": "DatasetReference"
							},
							"name": "TargetPersistentParquetInsert"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "ErrorTable"
						}
					],
					"transformations": [
						{
							"name": "ValidateMandatoryColumns",
							"description": "ReportingDateCertificationIDValidateMsg is a test and should be considered as part of the conditional split Insert/Update activity"
						},
						{
							"name": "SegregateValidInvalidRows"
						},
						{
							"name": "SelectedColumnsOutputInsert"
						},
						{
							"name": "ConcatenateInvalidColumnsMessage"
						},
						{
							"name": "SelectedOutputColumnsError"
						},
						{
							"name": "GenerateRowNumber"
						},
						{
							"name": "ExcludeFirstRowandEmpty"
						},
						{
							"name": "DataTypeTransformations"
						}
					],
					"script": "parameters{\n\tMasterUtcTag as string,\n\tCurrentRunDateTime as string,\n\tWorkbookName as string,\n\tTabName as string,\n\tCurrentQuarterDate as string,\n\tMasterPipeline as string\n}\nsource(output(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tReporting_Period as string,\n\t\tValidation_Flag as string,\n\t\tSales_Type as string,\n\t\tSales_UOM as string,\n\t\tSales_Point as string,\n\t\tTotal_Units_Sold as string,\n\t\tTotal_Revenue as string,\n\t\tTotal_Sales_Costs as string,\n\t\tTotal_Net_Revenue as string,\n\t\tSales_Net_Revenue_Per_Unit as string,\n\t\tCurrency_Code as string,\n\t\tBudget_Units_Sold as string,\n\t\tBudget_Sales_Revenue as string,\n\t\tBudget_Sales_Costs as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\tformat: 'parquet',\n\tpartitionBy('hash', 1)) ~> SourceDataTab\nExcludeFirstRowandEmpty derive(Sales_Type_Validate_Msg = iif(isNull(Sales_Type),'Sales Type/',''),\n\t\tTotal_Revenue_Validate_Msg = iif(isNull(Total_Revenue_toDecimal),'Total_Revenue/',''),\n\t\tAssetReportingDateValidateMsg = iif(isNull(Asset_ID) || isNull(Fund_ID) || isNull(Reporting_Period), \"Invalid Asset or Reporting Period/\", \"\")) ~> ValidateMandatoryColumns\nValidateMandatoryColumns split(length(concatWS('',Sales_Type_Validate_Msg,Total_Revenue_Validate_Msg,AssetReportingDateValidateMsg)) == 0,\n\tdisjoint: false) ~> SegregateValidInvalidRows@(ValidRows, InvalidRows)\nSegregateValidInvalidRows@ValidRows select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tSales_Type,\n\t\tSales_UOM,\n\t\tSales_Point,\n\t\tTotal_Units_Sold,\n\t\tSales_revenue = Total_Revenue_toDecimal,\n\t\tSales_Cost = Total_Sales_Costs,\n\t\tSales_Net_Revenue = Total_Net_Revenue,\n\t\tSales_Net_Revenue_Per_Unit,\n\t\tCurrency_Code,\n\t\tBudget_Sales_Quantity = Budget_Units_Sold,\n\t\tBudget_Sales_Revenue,\n\t\tBudget_Sales_Costs,\n\t\tInsert_Datetime,\n\t\tProcess_Name\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectedColumnsOutputInsert\nSegregateValidInvalidRows@InvalidRows derive(ConcatenatedMessage = concat(Sales_Type_Validate_Msg,Total_Revenue_Validate_Msg,AssetReportingDateValidateMsg)) ~> ConcatenateInvalidColumnsMessage\nConcatenateInvalidColumnsMessage select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tSales_Type,\n\t\tSales_UOM,\n\t\tSales_Point,\n\t\tTotal_Units_Sold,\n\t\tSales_revenue = Total_Revenue,\n\t\tSales_Cost = Total_Sales_Costs,\n\t\tSales_Net_Revenue = Total_Net_Revenue,\n\t\tSales_Net_Revenue_Per_Unit,\n\t\tCurrency_Code,\n\t\tBudget_Sales_Quantity = Budget_Units_Sold,\n\t\tBudget_Sales_Revenue,\n\t\tBudget_Sales_Costs,\n\t\tInsert_Datetime,\n\t\tSource_File = Work_Book,\n\t\tSource_Sub_File = Work_Sheet,\n\t\tProcess_Name,\n\t\tError_Desc = ConcatenatedMessage\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectedOutputColumnsError\nDataTypeTransformations keyGenerate(output(RowNumber as long),\n\tstartAt: 1L,\n\tstepValue: 1L,\n\tpartitionBy('hash', 1)) ~> GenerateRowNumber\nGenerateRowNumber filter(RowNumber > 1 && \r\n(not(isNull(Sales_Type)) || not(isNull(Sales_UOM)) || not(isNull(Sales_Point)) || \r\nnot(isNull(Total_Units_Sold)) || not(isNull(Total_Revenue)) || not(isNull(Total_Sales_Costs)) || \r\nnot(isNull(Currency_Code)) || not(isNull(Budget_Units_Sold)) || \r\nnot(isNull(Budget_Sales_Revenue)) || not(isNull(Budget_Sales_Costs))\r\n)) ~> ExcludeFirstRowandEmpty\nSourceDataTab derive(Reporting_Period = toDate(Reporting_Period),\n\t\tInsert_Datetime = fromUTC(currentUTC(), 'Australia/Sydney'),\n\t\tWork_Book = $WorkbookName,\n\t\tWork_Sheet = $TabName,\n\t\tProcess_Name = concatWS('-',$MasterPipeline,$WorkbookName,$TabName),\n\t\tCurrentReportingPeriod = toDate($CurrentQuarterDate),\n\t\tTotal_Units_Sold = toDecimal(Total_Units_Sold,19,4),\n\t\tTotal_Revenue_toDecimal = toDecimal(Total_Revenue,19,4),\n\t\tTotal_Sales_Costs = toDecimal(Total_Sales_Costs,19,4),\n\t\tTotal_Net_Revenue = toDecimal(Total_Net_Revenue,19,4),\n\t\tSales_Net_Revenue_Per_Unit = toDecimal(Sales_Net_Revenue_Per_Unit,19,4),\n\t\tBudget_Units_Sold = toDecimal(Budget_Units_Sold,19,4),\n\t\tBudget_Sales_Revenue = toDecimal(Budget_Sales_Revenue,19,4),\n\t\tBudget_Sales_Costs = toDecimal(Budget_Sales_Costs,19,4)) ~> DataTypeTransformations\nSelectedColumnsOutputInsert sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tformat: 'parquet',\n\tpartitionFileNames:[(concatWS(\"_\", $WorkbookName, $TabName,$CurrentQuarterDate,'LoadReady'))],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tSales_Type,\n\t\tSales_UOM,\n\t\tSales_Point,\n\t\tTotal_Units_Sold,\n\t\tSales_revenue,\n\t\tSales_Cost,\n\t\tSales_Net_Revenue,\n\t\tSales_Net_Revenue_Per_Unit,\n\t\tCurrency_Code,\n\t\tBudget_Sales_Quantity,\n\t\tBudget_Sales_Revenue,\n\t\tBudget_Sales_Costs,\n\t\tInsert_Datetime,\n\t\tProcess_Name\n\t),\n\tpartitionBy('hash', 1)) ~> TargetPersistentParquetInsert\nSelectedOutputColumnsError sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tSales_Type,\n\t\tSales_UOM,\n\t\tSales_Point,\n\t\tTotal_Units_Sold,\n\t\tSales_revenue,\n\t\tSales_Cost,\n\t\tSales_Net_Revenue,\n\t\tSales_Net_Revenue_Per_Unit,\n\t\tCurrency_Code,\n\t\tBudget_Sales_Quantity,\n\t\tBudget_Sales_Revenue,\n\t\tBudget_Sales_Costs,\n\t\tInsert_Datetime,\n\t\tSource_File,\n\t\tSource_Sub_File,\n\t\tProcess_Name,\n\t\tError_Desc\n\t),\n\tpartitionBy('hash', 1)) ~> ErrorTable"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadXlsxOtherSales_Step2_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ParquetPersistentOpsWithTabParam_ds",
								"type": "DatasetReference"
							},
							"name": "SourceReadyLoad"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "TargetRelational"
						}
					],
					"transformations": [
						{
							"name": "SelectKeyColumnsForDelete"
						},
						{
							"name": "AggregateAssetFundReportingPeriod"
						},
						{
							"name": "AlterRowDelete"
						}
					],
					"script": "parameters{\n\tWorkbookName as string,\n\tTabName as string\n}\nsource(output(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tReporting_Period as date,\n\t\tSales_Type as string,\n\t\tSales_UOM as string,\n\t\tSales_Point as string,\n\t\tTotal_Units_Sold as decimal(19,4),\n\t\tSales_revenue as decimal(19,4),\n\t\tSales_Cost as decimal(19,4),\n\t\tSales_Net_Revenue as decimal(19,4),\n\t\tSales_Net_Revenue_Per_Unit as decimal(19,4),\n\t\tCurrency_Code as string,\n\t\tBudget_Sales_Quantity as decimal(19,4),\n\t\tBudget_Sales_Revenue as decimal(19,4),\n\t\tBudget_Sales_Costs as decimal(19,4),\n\t\tInsert_Datetime as timestamp,\n\t\tProcess_Name as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\tformat: 'parquet',\n\tpartitionBy('hash', 1)) ~> SourceReadyLoad\nSourceReadyLoad select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectKeyColumnsForDelete\nSelectKeyColumnsForDelete aggregate(groupBy(Asset_ID,\n\t\tFund_ID,\n\t\tReporting_Period),\n\tUniqueCount = count()) ~> AggregateAssetFundReportingPeriod\nAggregateAssetFundReportingPeriod alterRow(deleteIf(UniqueCount>0)) ~> AlterRowDelete\nAlterRowDelete sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:true,\n\tinsertable:false,\n\tupdateable:false,\n\tupsertable:false,\n\tkeys:['Asset_ID','Fund_ID','Reporting_Period'],\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period\n\t),\n\tpartitionBy('hash', 1)) ~> TargetRelational"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadXlsxOtherSales_Step3_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ParquetPersistentOpsWithTabParam_ds",
								"type": "DatasetReference"
							},
							"name": "SourceReadyLoad"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "TargetRelational"
						}
					],
					"transformations": [
						{
							"name": "MapColumns"
						}
					],
					"script": "parameters{\n\tWorkbookName as string,\n\tTabName as string\n}\nsource(output(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tReporting_Period as date,\n\t\tSales_Type as string,\n\t\tSales_UOM as string,\n\t\tSales_Point as string,\n\t\tTotal_Units_Sold as decimal(19,4),\n\t\tSales_revenue as decimal(19,4),\n\t\tSales_Cost as decimal(19,4),\n\t\tSales_Net_Revenue as decimal(19,4),\n\t\tSales_Net_Revenue_Per_Unit as decimal(19,4),\n\t\tCurrency_Code as string,\n\t\tBudget_Sales_Quantity as decimal(19,4),\n\t\tBudget_Sales_Revenue as decimal(19,4),\n\t\tBudget_Sales_Costs as decimal(19,4),\n\t\tInsert_Datetime as timestamp,\n\t\tProcess_Name as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\tformat: 'parquet',\n\tpartitionBy('hash', 1)) ~> SourceReadyLoad\nSourceReadyLoad select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tSales_Type,\n\t\tSales_UOM,\n\t\tSales_Point,\n\t\tTotal_Units_Sold,\n\t\tSales_revenue,\n\t\tSales_Cost,\n\t\tSales_Net_Revenue,\n\t\tSales_Net_Revenue_Per_Unit,\n\t\tCurrency_Code,\n\t\tBudget_Sales_Quantity,\n\t\tBudget_Sales_Revenue,\n\t\tBudget_Sales_Costs,\n\t\tInsert_Datetime,\n\t\tProcess_Name\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> MapColumns\nMapColumns sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tSales_Type,\n\t\tSales_UOM,\n\t\tSales_Point,\n\t\tTotal_Units_Sold,\n\t\tSales_revenue,\n\t\tSales_Cost,\n\t\tSales_Net_Revenue,\n\t\tSales_Net_Revenue_Per_Unit,\n\t\tCurrency_Code,\n\t\tBudget_Sales_Quantity,\n\t\tBudget_Sales_Revenue,\n\t\tBudget_Sales_Costs,\n\t\tInsert_Datetime,\n\t\tProcess_Name\n\t),\n\tpartitionBy('hash', 1)) ~> TargetRelational"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadXlsxRelatedPartyTrans_Step1_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ParquetPersistentOpsWithTabParam_ds",
								"type": "DatasetReference"
							},
							"name": "SourceDataTab"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ParquetPersistentOps_ds",
								"type": "DatasetReference"
							},
							"name": "TargetPersistentParquetInsert"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "ErrorTable"
						}
					],
					"transformations": [
						{
							"name": "ValidateMandatoryColumns",
							"description": "ReportingDateCertificationIDValidateMsg is a test and should be considered as part of the conditional split Insert/Update activity"
						},
						{
							"name": "SegregateValidInvalidRows"
						},
						{
							"name": "SelectedColumnsOutputInsert"
						},
						{
							"name": "ConcatenateInvalidColumnsMessage"
						},
						{
							"name": "SelectedOutputColumnsError"
						},
						{
							"name": "GenerateRowNumber"
						},
						{
							"name": "ExcludeFirstRow"
						},
						{
							"name": "DateTypeTransform"
						}
					],
					"script": "parameters{\n\tMasterUtcTag as string,\n\tCurrentRunDateTime as string,\n\tWorkbookName as string,\n\tTabName as string,\n\tCurrentQuarterDate as string,\n\tMasterPipeline as string\n}\nsource(output(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tReporting_Period as string,\n\t\tTransaction_ID as string,\n\t\tValidation_Flag as string,\n\t\tTransaction_Date as string,\n\t\tRelated_Parties_Involved as string,\n\t\tTransaction_Description as string,\n\t\tTransaction_Size_Value as string,\n\t\tHow_Managed as string,\n\t\tHow_does_the_transaction_benefit_both_parties as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\tformat: 'parquet',\n\tpartitionBy('hash', 1)) ~> SourceDataTab\nExcludeFirstRow derive(Transaction_Date_Validate_Msg = iif(isNull(Transaction_Date),'Blank Transaction Date/',''),\n\t\tRelated_Parties_Involved_Validate_Msg = iif(isNull(Related_Parties_Involved),'Blank Related Parties Involved/',''),\n\t\tTransaction_Size_Value_Validate_Msg = iif(isNull(Transaction_Size_Value),'Blank Transaction Size Value/',''),\n\t\tAssetReportingDateValidateMsg = iif(isNull(Asset_ID) || isNull(Fund_ID) || isNull(Reporting_Period), \"Invalid Asset or Reporting Period/\", \"\")) ~> ValidateMandatoryColumns\nValidateMandatoryColumns split(length(concatWS('',Transaction_Date_Validate_Msg,Related_Parties_Involved_Validate_Msg,Transaction_Size_Value_Validate_Msg)) == 0,\n\tdisjoint: false) ~> SegregateValidInvalidRows@(ValidRows, InvalidRows)\nSegregateValidInvalidRows@ValidRows select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tValidation_Flag,\n\t\tTransaction_Date,\n\t\tRelated_Parties_Involved,\n\t\tTransaction_Description,\n\t\tTransaction_Size_Value,\n\t\tHow_Managed,\n\t\tHow_does_the_transaction_benefit_both_parties,\n\t\tInsert_Datetime,\n\t\tUpdate_Datetime,\n\t\tWork_Book,\n\t\tWork_Sheet,\n\t\tProcess_Name,\n\t\tCurrentReportingPeriod,\n\t\tRowNumber,\n\t\tAssetReportingDateValidateMsg\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectedColumnsOutputInsert\nSegregateValidInvalidRows@InvalidRows derive(ConcatenatedMessage = concat(Transaction_Date_Validate_Msg,Related_Parties_Involved_Validate_Msg,Transaction_Size_Value_Validate_Msg,AssetReportingDateValidateMsg)) ~> ConcatenateInvalidColumnsMessage\nConcatenateInvalidColumnsMessage select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tTransaction_Date,\n\t\tRelated_Parties_Involved,\n\t\tTransaction_Description,\n\t\tTransaction_Size_Value,\n\t\tHow_Managed,\n\t\tHow_does_the_transaction_benefit_both_parties,\n\t\tInsert_Datetime,\n\t\tUpdate_Datetime,\n\t\tWork_Book,\n\t\tWork_Sheet,\n\t\tProcess_Name,\n\t\tCurrentReportingPeriod,\n\t\tRowNumber,\n\t\tAssetReportingDateValidateMsg,\n\t\tError_Desc = ConcatenatedMessage\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectedOutputColumnsError\nDateTypeTransform keyGenerate(output(RowNumber as long),\n\tstartAt: 1L,\n\tstepValue: 1L,\n\tpartitionBy('hash', 1)) ~> GenerateRowNumber\nGenerateRowNumber filter(RowNumber > 1 &&\r\n(not(isNull(Transaction_Date)) || not(isNull(Related_Parties_Involved)) || not(isNull(Transaction_Description)) ||\r\nnot(isNull(Transaction_Size_Value)) || not(isNull(How_Managed)) || not(isNull(How_does_the_transaction_benefit_both_parties))\r\n)) ~> ExcludeFirstRow\nSourceDataTab derive(Insert_Datetime = fromUTC(currentUTC(), 'Australia/Sydney'),\n\t\tUpdate_Datetime = toTimestamp('9999-12-31 00:00:00'),\n\t\tWork_Book = $WorkbookName,\n\t\tWork_Sheet = $TabName,\n\t\tProcess_Name = concatWS('-',$MasterPipeline,$WorkbookName,$TabName),\n\t\tCurrentReportingPeriod = toDate($CurrentQuarterDate),\n\t\tReporting_Period = toDate(Reporting_Period),\n\t\tTransaction_Date = toDate(Transaction_Date),\n\t\tRelated_Parties_Involved = Related_Parties_Involved,\n\t\tTransaction_Description = Transaction_Description,\n\t\tTransaction_Size_Value = toDecimal(Transaction_Size_Value, 19, 4),\n\t\tHow_Managed = How_Managed,\n\t\tHow_does_the_transaction_benefit_both_parties = How_does_the_transaction_benefit_both_parties) ~> DateTypeTransform\nSelectedColumnsOutputInsert sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tformat: 'parquet',\n\tpartitionFileNames:[(concatWS(\"_\", $WorkbookName, $TabName,$CurrentQuarterDate,'LoadReady'))],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tValidation_Flag,\n\t\tTransaction_Date,\n\t\tRelated_Parties_Involved,\n\t\tTransaction_Description,\n\t\tTransaction_Size_Value,\n\t\tHow_Managed,\n\t\tHow_does_the_transaction_benefit_both_parties,\n\t\tInsert_Datetime,\n\t\tUpdate_Datetime,\n\t\tWork_Book,\n\t\tWork_Sheet,\n\t\tProcess_Name,\n\t\tCurrentReportingPeriod,\n\t\tRowNumber,\n\t\tAssetReportingDateValidateMsg\n\t),\n\tpartitionBy('hash', 1)) ~> TargetPersistentParquetInsert\nSelectedOutputColumnsError sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tTransaction_Date,\n\t\tRelated_Parties_Involved,\n\t\tTransaction_Description,\n\t\tTransaction_Size = Transaction_Size_Value,\n\t\tHow_Managed,\n\t\tMutual_Benefit = How_does_the_transaction_benefit_both_parties,\n\t\tInsert_Datetime,\n\t\tProcess_Name,\n\t\tSource_File = Work_Book,\n\t\tSource_Sub_File = Work_Sheet,\n\t\tError_Desc\n\t),\n\tpartitionBy('hash', 1)) ~> ErrorTable"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadXlsxRelatedPartyTrans_Step2_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ParquetPersistentOpsWithTabParam_ds",
								"type": "DatasetReference"
							},
							"name": "SourceReadyLoad"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLrelationopsRelatedPartyTrans_ds",
								"type": "DatasetReference"
							},
							"name": "TargetRelational"
						}
					],
					"transformations": [
						{
							"name": "SelectKeyColumnsForDelete"
						},
						{
							"name": "AggregateAssetFundReportingPeriod"
						},
						{
							"name": "AlterRowDelete"
						}
					],
					"script": "parameters{\n\tWorkbookName as string,\n\tTabName as string\n}\nsource(output(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tReporting_Period as string,\n\t\tValidation_Flag as string,\n\t\tReporting_Period2 as string,\n\t\tTransaction_Date as string,\n\t\tRelated_Parties_Involved as string,\n\t\tTransaction_Description as string,\n\t\tTransaction_Size_Value as string,\n\t\tHow_Managed as string,\n\t\t{How_does_the_transaction_benefit_both_parties?} as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\tformat: 'parquet',\n\tpartitionBy('hash', 1)) ~> SourceReadyLoad\nSourceReadyLoad select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectKeyColumnsForDelete\nSelectKeyColumnsForDelete aggregate(groupBy(Asset_ID,\n\t\tFund_ID,\n\t\tReporting_Period),\n\tUniqueCount = count()) ~> AggregateAssetFundReportingPeriod\nAggregateAssetFundReportingPeriod alterRow(deleteIf(UniqueCount>0)) ~> AlterRowDelete\nAlterRowDelete sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tinput(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tTransaction_ID_Old as integer,\n\t\tReporting_Period as date,\n\t\tTransaction_Date as date,\n\t\tRelated_Parties_Involved as string,\n\t\tTransaction_Description as string,\n\t\tTransaction_Size as decimal(19,4),\n\t\tHow_Managed as string,\n\t\tMutual_Benefit as string,\n\t\tInsert_Datetime as timestamp,\n\t\tUpdate_Datetime as timestamp,\n\t\tProcess_Name as string,\n\t\tTransaction_ID as integer\n\t),\n\tdeletable:true,\n\tinsertable:false,\n\tupdateable:false,\n\tupsertable:false,\n\tkeys:['Asset_ID','Fund_ID','Reporting_Period'],\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period\n\t),\n\tpartitionBy('hash', 1)) ~> TargetRelational"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadXlsxRelatedPartyTrans_Step3_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ParquetPersistentOpsWithTabParam_ds",
								"type": "DatasetReference"
							},
							"name": "SourceReadyLoad"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLrelationopsRelatedPartyTrans_ds",
								"type": "DatasetReference"
							},
							"name": "TargetRelational"
						}
					],
					"transformations": [
						{
							"name": "MapColumns"
						}
					],
					"script": "parameters{\n\tWorkbookName as string,\n\tTabName as string\n}\nsource(output(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tReporting_Period as date,\n\t\tValidation_Flag as string,\n\t\tTransaction_Date as date,\n\t\tRelated_Parties_Involved as string,\n\t\tTransaction_Description as string,\n\t\tTransaction_Size_Value as decimal(19,4),\n\t\tHow_Managed as string,\n\t\tHow_does_the_transaction_benefit_both_parties as string,\n\t\tInsert_Datetime as timestamp,\n\t\tUpdate_Datetime as timestamp,\n\t\tWork_Book as string,\n\t\tWork_Sheet as string,\n\t\tProcess_Name as string,\n\t\tCurrentReportingPeriod as date,\n\t\tRowNumber as long,\n\t\tAssetReportingDateValidateMsg as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\tformat: 'parquet',\n\tpartitionBy('hash', 1)) ~> SourceReadyLoad\nSourceReadyLoad select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tTransaction_Date,\n\t\tRelated_Parties_Involved,\n\t\tTransaction_Description,\n\t\tTransaction_Size_Value,\n\t\tHow_Managed,\n\t\tHow_does_the_transaction_benefit_both_parties,\n\t\tInsert_Datetime,\n\t\tUpdate_Datetime,\n\t\tWork_Book,\n\t\tWork_Sheet,\n\t\tProcess_Name,\n\t\tCurrentReportingPeriod,\n\t\tRowNumber,\n\t\tAssetReportingDateValidateMsg\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> MapColumns\nMapColumns sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tinput(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tTransaction_ID_Old as integer,\n\t\tReporting_Period as date,\n\t\tTransaction_Date as date,\n\t\tRelated_Parties_Involved as string,\n\t\tTransaction_Description as string,\n\t\tTransaction_Size as decimal(19,4),\n\t\tHow_Managed as string,\n\t\tMutual_Benefit as string,\n\t\tInsert_Datetime as timestamp,\n\t\tUpdate_Datetime as timestamp,\n\t\tProcess_Name as string,\n\t\tTransaction_ID as integer\n\t),\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tTransaction_Date,\n\t\tRelated_Parties_Involved,\n\t\tTransaction_Description,\n\t\tTransaction_Size = Transaction_Size_Value,\n\t\tHow_Managed,\n\t\tMutual_Benefit = How_does_the_transaction_benefit_both_parties,\n\t\tInsert_Datetime,\n\t\tUpdate_Datetime,\n\t\tProcess_Name\n\t),\n\tpartitionBy('hash', 1)) ~> TargetRelational"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadXlsxRiskOps_Step1_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ParquetPersistentOpsWithTabParam_ds",
								"type": "DatasetReference"
							},
							"name": "SourceDataTab"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGeneric_ds",
								"type": "DatasetReference"
							},
							"name": "RelationalRiskOpsRegister"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "ParquetPersistentOps_ds",
								"type": "DatasetReference"
							},
							"name": "TargetPersistentParquetInsert"
						},
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "ErrorTable"
						},
						{
							"dataset": {
								"referenceName": "ParquetPersistentOps_ds",
								"type": "DatasetReference"
							},
							"name": "TargetPersistenParquetUpdate"
						}
					],
					"transformations": [
						{
							"name": "ValidateMandatoryColumns",
							"description": "ReportingDateCertificationIDValidateMsg is a test and should be considered as part of the conditional split Insert/Update activity"
						},
						{
							"name": "SegregateValidInvalidRows"
						},
						{
							"name": "SelectedColumnsOutputInsert"
						},
						{
							"name": "ConcatenateInvalidColumnsMessage"
						},
						{
							"name": "SelectedOutputColumnsError"
						},
						{
							"name": "GenerateRowNumber"
						},
						{
							"name": "ExcludeFirstRowandEmpty"
						},
						{
							"name": "DateTypeTransform"
						},
						{
							"name": "SplitInsertAndUpdate",
							"description": "1. The condition assume that the records from the current reporting period are deleted first if any (asset id, fund id, current reporting period)\n2. Records where reporting period equal current reporting period (disregard certification id) are inserted/reinserted after delete in 1\n3. Remaining records are not from current reporting period and the certification ids must not be null. These are updated"
						},
						{
							"name": "SelectColumnsOutputUpdate"
						},
						{
							"name": "UpdateDatetimeValue"
						},
						{
							"name": "LookupRiskOp"
						},
						{
							"name": "SelectRiskOpsLookup"
						}
					],
					"script": "parameters{\n\tMasterUtcTag as string,\n\tCurrentRunDateTime as string,\n\tWorkbookName as string,\n\tTabName as string,\n\tCurrentQuarterDate as string,\n\tMasterPipeline as string\n}\nsource(output(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tReporting_Period as string,\n\t\tRisk_Opp_ID as string,\n\t\tValidation_Flag as string,\n\t\tRisk_Sub_Class as string,\n\t\tRisk_Class as string,\n\t\tRisk_Description as string,\n\t\tActions_and_Controls as string,\n\t\tDate_Lodged as string,\n\t\tLikelihood as string,\n\t\tSeverity as string,\n\t\tInherent_Risk_Rating as string,\n\t\tEliminate_or_Mitigate as string,\n\t\tResidual_Likelihood as string,\n\t\tResidual_Severity as string,\n\t\tResidual_Risk_Rating as string,\n\t\tFuture_Controls as string,\n\t\tPerson_Responsible as string,\n\t\tDate_Closed as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\tformat: 'parquet',\n\tpartitionBy('hash', 1)) ~> SourceDataTab\nsource(output(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tReporting_Period as date,\n\t\tRisk_Ops_Sub_Class_Code as string,\n\t\tRisk_Ops_Descripton as string,\n\t\tActions_Controls as string,\n\t\tDate_Lodged as date,\n\t\tLikelihood as short,\n\t\tSeverity as short,\n\t\tInherent_Risk_Rating as short,\n\t\tEliminate_Mitigate as string,\n\t\tResidual_Likelihood as short,\n\t\tResidual_Severity as short,\n\t\tResidual_Risk_Rating as short,\n\t\tFuture_Controls as string,\n\t\tPerson_Responsible as string,\n\t\tDate_Closed as date,\n\t\tQuarterly_Incidents as integer,\n\t\tRisk_Opps_Flag as string,\n\t\tInsert_Datetime as timestamp,\n\t\tRisk_Opp_ID as integer,\n\t\tRisk_Opp_Class as string,\n\t\tRisk_Opp_Sub_Class as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tisolationLevel: 'READ_UNCOMMITTED',\n\tquery: 'SELECT DISTINCT [Asset_ID]\\n      ,[Fund_ID]\\n      ,[Reporting_Period]\\n      ,[Risk_Ops_Sub_Class_Code]\\n      ,[Risk_Ops_Descripton]\\n      ,[Actions_Controls]\\n      ,[Date_Lodged]\\n      ,[Likelihood]\\n      ,[Severity]\\n      ,[Inherent_Risk_Rating]\\n      ,[Eliminate_Mitigate]\\n      ,[Residual_Likelihood]\\n      ,[Residual_Severity]\\n      ,[Residual_Risk_Rating]\\n      ,[Future_Controls]\\n      ,[Person_Responsible]\\n      ,[Date_Closed]\\n      ,[Quarterly_Incidents]\\n      ,[Risk_Opps_Flag]\\n      ,[Insert_Datetime]\\n      ,[Risk_Opp_ID]\\n      ,[Risk_Opp_Class]\\n      ,[Risk_Opp_Sub_Class]\\n  FROM [relational].[OPS_Risk_Opportunity_Register]',\n\tformat: 'query') ~> RelationalRiskOpsRegister\nLookupRiskOp derive(Risk_Class_Validate_Msg = iif(isNull(Risk_Class),'Risk Class/',''),\n\t\tDate_Lodged_Validate_Msg = iif(isNull(Date_Lodged_toDate),'Date Lodged/',''),\n\t\tAssetReportingDateValidateMsg = iif(isNull(Asset_ID) || isNull(Fund_ID) || isNull(Reporting_Period), \"Invalid Asset or Reporting Period/\", \"\"),\n\t\tReportingDateContractIDValidateMsg = iif(iif(CurrentReportingPeriod != Reporting_Period, true(), false()) && isNull(Risk_Opp_ID),\"Null Contract ID for non-current Reporting Period/\",\"\"),\n\t\tLkpRelationalContractIDValidateMsg = iif(not(isNull(Risk_Opp_ID_Lkp)),\r\niif(equals(concat(Asset_ID_Lkp,Fund_ID_Lkp), concat(Asset_ID,Fund_ID)),\"\",\"Contract ID not belong to Asset/\"),\"\")) ~> ValidateMandatoryColumns\nValidateMandatoryColumns split(length(concatWS('',Risk_Class_Validate_Msg,Date_Lodged_Validate_Msg,AssetReportingDateValidateMsg,ReportingDateContractIDValidateMsg,LkpRelationalContractIDValidateMsg)) == 0,\n\tdisjoint: false) ~> SegregateValidInvalidRows@(ValidRows, InvalidRows)\nSplitInsertAndUpdate@Insert select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tRisk_Opp_Sub_Class = Risk_Sub_Class,\n\t\tRisk_Opp_Class = Risk_Class,\n\t\tRisk_Ops_Descripton = Risk_Description,\n\t\tActions_Controls = Actions_and_Controls,\n\t\tDate_Lodged = Date_Lodged_toDate,\n\t\tLikelihood,\n\t\tSeverity,\n\t\tInherent_Risk_Rating,\n\t\tEliminate_Mitigate = Eliminate_or_Mitigate,\n\t\tResidual_Likelihood,\n\t\tResidual_Severity,\n\t\tResidual_Risk_Rating,\n\t\tFuture_Controls,\n\t\tPerson_Responsible,\n\t\tDate_Closed,\n\t\tInsert_Datetime,\n\t\tProcess_Name\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectedColumnsOutputInsert\nSegregateValidInvalidRows@InvalidRows derive(ConcatenatedMessage = concat(Risk_Class_Validate_Msg,Date_Lodged_Validate_Msg,AssetReportingDateValidateMsg,ReportingDateContractIDValidateMsg,LkpRelationalContractIDValidateMsg)) ~> ConcatenateInvalidColumnsMessage\nConcatenateInvalidColumnsMessage select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tRisk_Opp_ID,\n\t\tRisk_Ops_Sub_Class = Risk_Sub_Class,\n\t\tRisk_Opp_Class = Risk_Class,\n\t\tRisk_Ops_Descripton = Risk_Description,\n\t\tActions_Controls = Actions_and_Controls,\n\t\tDate_Lodged,\n\t\tLikelihood,\n\t\tSeverity,\n\t\tInherent_Risk_Rating,\n\t\tEliminate_Mitigate = Eliminate_or_Mitigate,\n\t\tResidual_Likelihood,\n\t\tResidual_Severity,\n\t\tResidual_Risk_Rating,\n\t\tFuture_Controls,\n\t\tPerson_Responsible,\n\t\tDate_Closed,\n\t\tInsert_Datetime,\n\t\tSource_File = Work_Book,\n\t\tSource_Sub_File = Work_Sheet,\n\t\tProcess_Name,\n\t\tError_Desc = ConcatenatedMessage\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectedOutputColumnsError\nDateTypeTransform keyGenerate(output(RowNumber as long),\n\tstartAt: 1L,\n\tstepValue: 1L,\n\tpartitionBy('hash', 1)) ~> GenerateRowNumber\nGenerateRowNumber filter(RowNumber > 1 && \r\n(not(isNull(Risk_Sub_Class)) || not(isNull(Risk_Class)) || \r\nnot(isNull(Risk_Description)) || not(isNull(Actions_and_Controls)) || not(isNull(Date_Lodged)) || \r\nnot(isNull(Likelihood)) || not(isNull(Severity)) || not(isNull(Inherent_Risk_Rating)) || not(isNull(Eliminate_or_Mitigate)) || \r\nnot(isNull(Residual_Likelihood)) || not(isNull(Residual_Severity)) || not(isNull(Residual_Risk_Rating)) || \r\nnot(isNull(Future_Controls)) || not(isNull(Person_Responsible)) || not(isNull(Date_Closed))\r\n)) ~> ExcludeFirstRowandEmpty\nSourceDataTab derive(Risk_Opp_ID = toInteger(Risk_Opp_ID),\n\t\tReporting_Period = toDate(Reporting_Period),\n\t\tLikelihood = toShort(Likelihood),\n\t\tSeverity = toShort(Severity),\n\t\tInherent_Risk_Rating = toShort(Inherent_Risk_Rating),\n\t\tResidual_Likelihood = toShort(Residual_Likelihood),\n\t\tResidual_Severity = toShort(Residual_Severity),\n\t\tResidual_Risk_Rating = toShort(Residual_Risk_Rating),\n\t\tDate_Closed = toDate(Date_Closed),\n\t\tDate_Lodged_toDate = toDate(Date_Lodged),\n\t\tInsert_Datetime = fromUTC(currentUTC(), 'Australia/Sydney'),\n\t\tUpdate_Datetime = toTimestamp('9999-12-31 00:00:00'),\n\t\tWork_Book = $WorkbookName,\n\t\tWork_Sheet = $TabName,\n\t\tProcess_Name = concatWS('-',$MasterPipeline,$WorkbookName,$TabName),\n\t\tCurrentReportingPeriod = toDate($CurrentQuarterDate)) ~> DateTypeTransform\nSegregateValidInvalidRows@ValidRows split(equals(Reporting_Period, CurrentReportingPeriod),\n\tdisjoint: false) ~> SplitInsertAndUpdate@(Insert, Update)\nUpdateDatetimeValue select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tRisk_Opp_ID,\n\t\tRisk_Opp_Sub_Class = Risk_Sub_Class,\n\t\tRisk_Opp_Class = Risk_Class,\n\t\tRisk_Ops_Descripton = Risk_Description,\n\t\tActions_Controls = Actions_and_Controls,\n\t\tDate_Lodged = Date_Lodged_toDate,\n\t\tLikelihood,\n\t\tSeverity,\n\t\tInherent_Risk_Rating,\n\t\tEliminate_Mitigate = Eliminate_or_Mitigate,\n\t\tResidual_Likelihood,\n\t\tResidual_Severity,\n\t\tResidual_Risk_Rating,\n\t\tFuture_Controls,\n\t\tPerson_Responsible,\n\t\tDate_Closed,\n\t\tInsert_Datetime,\n\t\tUpdate_Datetime,\n\t\tProcess_Name\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectColumnsOutputUpdate\nSplitInsertAndUpdate@Update derive(Update_Datetime = fromUTC(currentUTC(), 'Australia/Sydney')) ~> UpdateDatetimeValue\nExcludeFirstRowandEmpty, SelectRiskOpsLookup lookup(Risk_Opp_ID == Risk_Opp_ID_Lkp,\n\tmultiple: false,\n\tpickup: 'any',\n\tbroadcast: 'auto')~> LookupRiskOp\nRelationalRiskOpsRegister select(mapColumn(\n\t\tAsset_ID_Lkp = Asset_ID,\n\t\tFund_ID_Lkp = Fund_ID,\n\t\tReporting_Period_Lkp = Reporting_Period,\n\t\tRisk_Ops_Sub_Class_Code_Lkp = Risk_Ops_Sub_Class_Code,\n\t\tRisk_Ops_Descripton_Lkp = Risk_Ops_Descripton,\n\t\tActions_Controls_Lkp = Actions_Controls,\n\t\tDate_Lodged_Lkp = Date_Lodged,\n\t\tLikelihood_Lkp = Likelihood,\n\t\tSeverity_Lkp = Severity,\n\t\tInherent_Risk_Rating_Lkp = Inherent_Risk_Rating,\n\t\tEliminate_Mitigate_Lkp = Eliminate_Mitigate,\n\t\tResidual_Likelihood_Lkp = Residual_Likelihood,\n\t\tResidual_Severity_Lkp = Residual_Severity,\n\t\tResidual_Risk_Rating_Lkp = Residual_Risk_Rating,\n\t\tFuture_Controls_Lkp = Future_Controls,\n\t\tPerson_Responsible_Lkp = Person_Responsible,\n\t\tDate_Closed_Lkp = Date_Closed,\n\t\tQuarterly_Incidents_Lkp = Quarterly_Incidents,\n\t\tRisk_Opps_Flag_Lkp = Risk_Opps_Flag,\n\t\tInsert_Datetime_Lkp = Insert_Datetime,\n\t\tRisk_Opp_ID_Lkp = Risk_Opp_ID,\n\t\tRisk_Opp_Class_Lkp = Risk_Opp_Class,\n\t\tRisk_Opp_Sub_Class_Lkp = Risk_Opp_Sub_Class\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectRiskOpsLookup\nSelectedColumnsOutputInsert sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tformat: 'parquet',\n\tpartitionFileNames:[(concatWS(\"_\", $WorkbookName, $TabName,$CurrentQuarterDate,'LoadReady'))],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tRisk_Opp_Sub_Class,\n\t\tRisk_Opp_Class,\n\t\tRisk_Ops_Descripton,\n\t\tActions_Controls,\n\t\tDate_Lodged,\n\t\tLikelihood,\n\t\tSeverity,\n\t\tInherent_Risk_Rating,\n\t\tEliminate_Mitigate,\n\t\tResidual_Likelihood,\n\t\tResidual_Severity,\n\t\tResidual_Risk_Rating,\n\t\tFuture_Controls,\n\t\tPerson_Responsible,\n\t\tDate_Closed,\n\t\tInsert_Datetime,\n\t\tProcess_Name\n\t),\n\tpartitionBy('hash', 1)) ~> TargetPersistentParquetInsert\nSelectedOutputColumnsError sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tRisk_Opp_ID,\n\t\tRisk_Ops_Sub_Class,\n\t\tRisk_Opp_Class,\n\t\tRisk_Ops_Descripton,\n\t\tActions_Controls,\n\t\tDate_Lodged,\n\t\tLikelihood,\n\t\tSeverity,\n\t\tInherent_Risk_Rating,\n\t\tEliminate_Mitigate,\n\t\tResidual_Likelihood,\n\t\tResidual_Severity,\n\t\tResidual_Risk_Rating,\n\t\tFuture_Controls,\n\t\tPerson_Responsible,\n\t\tDate_Closed,\n\t\tInsert_Datetime,\n\t\tSource_File,\n\t\tSource_Sub_File,\n\t\tProcess_Name,\n\t\tError_Desc\n\t),\n\tpartitionBy('hash', 1)) ~> ErrorTable\nSelectColumnsOutputUpdate sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tformat: 'parquet',\n\tpartitionFileNames:[(concatWS(\"_\", $WorkbookName, $TabName,$CurrentQuarterDate,'Update'))],\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tRisk_Opp_ID,\n\t\tRisk_Opp_Sub_Class,\n\t\tRisk_Opp_Class,\n\t\tRisk_Ops_Descripton,\n\t\tActions_Controls,\n\t\tDate_Lodged,\n\t\tLikelihood,\n\t\tSeverity,\n\t\tInherent_Risk_Rating,\n\t\tEliminate_Mitigate,\n\t\tResidual_Likelihood,\n\t\tResidual_Severity,\n\t\tResidual_Risk_Rating,\n\t\tFuture_Controls,\n\t\tPerson_Responsible,\n\t\tDate_Closed,\n\t\tInsert_Datetime,\n\t\tUpdate_Datetime,\n\t\tProcess_Name\n\t),\n\tpartitionBy('hash', 1)) ~> TargetPersistenParquetUpdate"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadXlsxRiskOps_Step2_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ParquetPersistentOpsWithTabParam_ds",
								"type": "DatasetReference"
							},
							"name": "SourceReadyLoad"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "TargetRelationalDelete"
						}
					],
					"transformations": [
						{
							"name": "SelectColumnsForDelete"
						},
						{
							"name": "AggregateAssetFundReportingPeriod"
						},
						{
							"name": "AlterRowDelete"
						}
					],
					"script": "parameters{\n\tWorkbookName as string,\n\tTabName as string\n}\nsource(output(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tReporting_Period as date,\n\t\tRisk_Opp_Sub_Class as string,\n\t\tRisk_Opp_Class as string,\n\t\tRisk_Ops_Descripton as string,\n\t\tActions_Controls as string,\n\t\tDate_Lodged as date,\n\t\tLikelihood as short,\n\t\tSeverity as short,\n\t\tInherent_Risk_Rating as short,\n\t\tEliminate_Mitigate as string,\n\t\tResidual_Likelihood as short,\n\t\tResidual_Severity as short,\n\t\tResidual_Risk_Rating as short,\n\t\tFuture_Controls as string,\n\t\tPerson_Responsible as string,\n\t\tDate_Closed as date,\n\t\tInsert_Datetime as timestamp,\n\t\tProcess_Name as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\tformat: 'parquet',\n\tpartitionBy('hash', 1)) ~> SourceReadyLoad\nSourceReadyLoad select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> SelectColumnsForDelete\nSelectColumnsForDelete aggregate(groupBy(Asset_ID,\n\t\tFund_ID,\n\t\tReporting_Period),\n\tUniqueCount = count()) ~> AggregateAssetFundReportingPeriod\nAggregateAssetFundReportingPeriod alterRow(deleteIf(UniqueCount>0)) ~> AlterRowDelete\nAlterRowDelete sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:true,\n\tinsertable:false,\n\tupdateable:false,\n\tupsertable:false,\n\tkeys:['Asset_ID','Fund_ID','Reporting_Period'],\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period\n\t),\n\tpartitionBy('hash', 1)) ~> TargetRelationalDelete"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadXlsxRiskOps_Step3_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ParquetPersistentOpsWithTabParam_ds",
								"type": "DatasetReference"
							},
							"name": "SourceReadyLoad"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "TargetRelational"
						}
					],
					"transformations": [
						{
							"name": "MapColumns"
						}
					],
					"script": "parameters{\n\tWorkbookName as string,\n\tTabName as string\n}\nsource(output(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tReporting_Period as date,\n\t\tRisk_Opp_Sub_Class as string,\n\t\tRisk_Opp_Class as string,\n\t\tRisk_Ops_Descripton as string,\n\t\tActions_Controls as string,\n\t\tDate_Lodged as date,\n\t\tLikelihood as short,\n\t\tSeverity as short,\n\t\tInherent_Risk_Rating as short,\n\t\tEliminate_Mitigate as string,\n\t\tResidual_Likelihood as short,\n\t\tResidual_Severity as short,\n\t\tResidual_Risk_Rating as short,\n\t\tFuture_Controls as string,\n\t\tPerson_Responsible as string,\n\t\tDate_Closed as date,\n\t\tInsert_Datetime as timestamp,\n\t\tProcess_Name as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\tformat: 'parquet',\n\tpartitionBy('hash', 1)) ~> SourceReadyLoad\nSourceReadyLoad select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tRisk_Opp_Sub_Class,\n\t\tRisk_Opp_Class,\n\t\tRisk_Ops_Descripton,\n\t\tActions_Controls,\n\t\tDate_Lodged,\n\t\tLikelihood,\n\t\tSeverity,\n\t\tInherent_Risk_Rating,\n\t\tEliminate_Mitigate,\n\t\tResidual_Likelihood,\n\t\tResidual_Severity,\n\t\tResidual_Risk_Rating,\n\t\tFuture_Controls,\n\t\tPerson_Responsible,\n\t\tDate_Closed,\n\t\tInsert_Datetime,\n\t\tProcess_Name\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> MapColumns\nMapColumns sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:true,\n\tupdateable:false,\n\tupsertable:false,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tRisk_Opp_Sub_Class,\n\t\tRisk_Opp_Class,\n\t\tRisk_Ops_Descripton,\n\t\tActions_Controls,\n\t\tDate_Lodged,\n\t\tLikelihood,\n\t\tSeverity,\n\t\tInherent_Risk_Rating,\n\t\tEliminate_Mitigate,\n\t\tResidual_Likelihood,\n\t\tResidual_Severity,\n\t\tResidual_Risk_Rating,\n\t\tFuture_Controls,\n\t\tPerson_Responsible,\n\t\tDate_Closed,\n\t\tInsert_Datetime,\n\t\tProcess_Name\n\t),\n\tpartitionBy('hash', 1)) ~> TargetRelational"
				}
			},
			"dependsOn": []
		},
		{
			"name": "[concat(parameters('factoryName'), '/LoadXlsxRiskOps_Step4_df')]",
			"type": "Microsoft.DataFactory/factories/dataflows",
			"apiVersion": "2018-06-01",
			"properties": {
				"type": "MappingDataFlow",
				"typeProperties": {
					"sources": [
						{
							"dataset": {
								"referenceName": "ParquetPersistentOpsWithTabParam_ds",
								"type": "DatasetReference"
							},
							"name": "SourceUpdate"
						}
					],
					"sinks": [
						{
							"dataset": {
								"referenceName": "SQLtableGenericWithParam_ds",
								"type": "DatasetReference"
							},
							"name": "TargetRelational"
						}
					],
					"transformations": [
						{
							"name": "MapColumns"
						},
						{
							"name": "AlterRowUpdate"
						}
					],
					"script": "parameters{\n\tWorkbookName as string,\n\tTabName as string\n}\nsource(output(\n\t\tAsset_ID as string,\n\t\tFund_ID as string,\n\t\tReporting_Period as date,\n\t\tRisk_Opp_ID as integer,\n\t\tRisk_Opp_Sub_Class as string,\n\t\tRisk_Opp_Class as string,\n\t\tRisk_Ops_Descripton as string,\n\t\tActions_Controls as string,\n\t\tDate_Lodged as date,\n\t\tLikelihood as short,\n\t\tSeverity as short,\n\t\tInherent_Risk_Rating as short,\n\t\tEliminate_Mitigate as string,\n\t\tResidual_Likelihood as short,\n\t\tResidual_Severity as short,\n\t\tResidual_Risk_Rating as short,\n\t\tFuture_Controls as string,\n\t\tPerson_Responsible as string,\n\t\tDate_Closed as date,\n\t\tInsert_Datetime as timestamp,\n\t\tUpdate_Datetime as timestamp,\n\t\tProcess_Name as string\n\t),\n\tallowSchemaDrift: true,\n\tvalidateSchema: false,\n\tignoreNoFilesFound: false,\n\tformat: 'parquet',\n\tpartitionBy('hash', 1)) ~> SourceUpdate\nSourceUpdate select(mapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tRisk_Opp_ID,\n\t\tRisk_Opp_Sub_Class,\n\t\tRisk_Opp_Class,\n\t\tRisk_Ops_Descripton,\n\t\tActions_Controls,\n\t\tDate_Lodged,\n\t\tLikelihood,\n\t\tSeverity,\n\t\tInherent_Risk_Rating,\n\t\tEliminate_Mitigate,\n\t\tResidual_Likelihood,\n\t\tResidual_Severity,\n\t\tResidual_Risk_Rating,\n\t\tFuture_Controls,\n\t\tPerson_Responsible,\n\t\tDate_Closed,\n\t\tInsert_Datetime,\n\t\tUpdate_Datetime,\n\t\tProcess_Name\n\t),\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true) ~> MapColumns\nMapColumns alterRow(updateIf(not(isNull(Risk_Opp_ID)))) ~> AlterRowUpdate\nAlterRowUpdate sink(allowSchemaDrift: true,\n\tvalidateSchema: false,\n\tdeletable:false,\n\tinsertable:false,\n\tupdateable:true,\n\tupsertable:false,\n\tkeys:['Risk_Opp_ID'],\n\tskipKeyWrites:true,\n\tformat: 'table',\n\tskipDuplicateMapInputs: true,\n\tskipDuplicateMapOutputs: true,\n\terrorHandlingOption: 'stopOnFirstError',\n\tmapColumn(\n\t\tAsset_ID,\n\t\tFund_ID,\n\t\tReporting_Period,\n\t\tRisk_Opp_ID,\n\t\tRisk_Opp_Sub_Class,\n\t\tRisk_Opp_Class,\n\t\tRisk_Ops_Descripton,\n\t\tActions_Controls,\n\t\tDate_Lodged,\n\t\tLikelihood,\n\t\tSeverity,\n\t\tInherent_Risk_Rating,\n\t\tEliminate_Mitigate,\n\t\tResidual_Likelihood,\n\t\tResidual_Severity,\n\t\tResidual_Risk_Rating,\n\t\tFuture_Controls,\n\t\tPerson_Responsible,\n\t\tDate_Closed,\n\t\tInsert_Datetime,\n\t\tUpdate_Datetime,\n\t\tProcess_Name\n\t),\n\tpartitionBy('hash', 1)) ~> TargetRelational"
				}
			},
			"dependsOn": []
		}
	]
}